<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.5"/>
<title>Hazelcast C++ Client: hazelcast::client::ICountDownLatch Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Hazelcast C++ Client
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.5 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>hazelcast</b></li><li class="navelem"><b>client</b></li><li class="navelem"><a class="el" href="classhazelcast_1_1client_1_1_i_count_down_latch.html">ICountDownLatch</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classhazelcast_1_1client_1_1_i_count_down_latch-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">hazelcast::client::ICountDownLatch Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><a class="el" href="classhazelcast_1_1client_1_1_i_count_down_latch.html" title="ICountDownLatch is a backed-up distributed alternative to the java.util.concurrent.CountDownLatch java.util.concurrent.CountDownLatch. ">ICountDownLatch</a> is a backed-up distributed alternative to the java.util.concurrent.CountDownLatch java.util.concurrent.CountDownLatch.  
 <a href="classhazelcast_1_1client_1_1_i_count_down_latch.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_i_count_down_latch_8h_source.html">ICountDownLatch.h</a>&gt;</code></p>
<div id="dynsection-0" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-0-trigger" src="closed.png" alt="+"/> Inheritance diagram for hazelcast::client::ICountDownLatch:</div>
<div id="dynsection-0-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-0-content" class="dyncontent" style="display:none;">
 <div class="center">
  <img src="classhazelcast_1_1client_1_1_i_count_down_latch.png" usemap="#hazelcast::client::ICountDownLatch_map" alt=""/>
  <map id="hazelcast::client::ICountDownLatch_map" name="hazelcast::client::ICountDownLatch_map">
<area href="classhazelcast_1_1client_1_1_distributed_object.html" title="Base class for all distributed objects. " alt="hazelcast::client::DistributedObject" shape="rect" coords="0,0,206,24"/>
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a082475738f0de687772ce0c18120ee54"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhazelcast_1_1client_1_1_i_count_down_latch.html#a082475738f0de687772ce0c18120ee54">await</a> (long timeoutInMillis)</td></tr>
<tr class="memdesc:a082475738f0de687772ce0c18120ee54"><td class="mdescLeft">&#160;</td><td class="mdescRight">Causes the current thread to wait until the latch has counted down to zero, an exception is thrown, or the specified waiting time elapses.  <a href="#a082475738f0de687772ce0c18120ee54">More...</a><br/></td></tr>
<tr class="separator:a082475738f0de687772ce0c18120ee54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0aa22b0764bfda816269cae74357c95b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhazelcast_1_1client_1_1_i_count_down_latch.html#a0aa22b0764bfda816269cae74357c95b">countDown</a> ()</td></tr>
<tr class="memdesc:a0aa22b0764bfda816269cae74357c95b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decrements the count of the latch, releasing all waiting threads if the count reaches zero.  <a href="#a0aa22b0764bfda816269cae74357c95b">More...</a><br/></td></tr>
<tr class="separator:a0aa22b0764bfda816269cae74357c95b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25f9ae16b66a2c035389d5399cab911a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhazelcast_1_1client_1_1_i_count_down_latch.html#a25f9ae16b66a2c035389d5399cab911a">getCount</a> ()</td></tr>
<tr class="memdesc:a25f9ae16b66a2c035389d5399cab911a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the current count.  <a href="#a25f9ae16b66a2c035389d5399cab911a">More...</a><br/></td></tr>
<tr class="separator:a25f9ae16b66a2c035389d5399cab911a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe33c0abc6d3ea0c8cee24f3bb851ad0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhazelcast_1_1client_1_1_i_count_down_latch.html#abe33c0abc6d3ea0c8cee24f3bb851ad0">trySetCount</a> (int count)</td></tr>
<tr class="memdesc:abe33c0abc6d3ea0c8cee24f3bb851ad0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the count to the given value if the current count is zero.  <a href="#abe33c0abc6d3ea0c8cee24f3bb851ad0">More...</a><br/></td></tr>
<tr class="separator:abe33c0abc6d3ea0c8cee24f3bb851ad0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classhazelcast_1_1client_1_1_distributed_object"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classhazelcast_1_1client_1_1_distributed_object')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classhazelcast_1_1client_1_1_distributed_object.html">hazelcast::client::DistributedObject</a></td></tr>
<tr class="memitem:a1990ab399703e9e977f82e148a66e579 inherit pub_methods_classhazelcast_1_1client_1_1_distributed_object"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1990ab399703e9e977f82e148a66e579"></a>
const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhazelcast_1_1client_1_1_distributed_object.html#a1990ab399703e9e977f82e148a66e579">getServiceName</a> () const </td></tr>
<tr class="memdesc:a1990ab399703e9e977f82e148a66e579 inherit pub_methods_classhazelcast_1_1client_1_1_distributed_object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the service name for this object. <br/></td></tr>
<tr class="separator:a1990ab399703e9e977f82e148a66e579 inherit pub_methods_classhazelcast_1_1client_1_1_distributed_object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b690bc99d8eb5909b07f41e1d884dd7 inherit pub_methods_classhazelcast_1_1client_1_1_distributed_object"><td class="memItemLeft" align="right" valign="top">const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhazelcast_1_1client_1_1_distributed_object.html#a5b690bc99d8eb5909b07f41e1d884dd7">getName</a> () const </td></tr>
<tr class="memdesc:a5b690bc99d8eb5909b07f41e1d884dd7 inherit pub_methods_classhazelcast_1_1client_1_1_distributed_object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the unique name for this <a class="el" href="classhazelcast_1_1client_1_1_distributed_object.html" title="Base class for all distributed objects. ">DistributedObject</a>.  <a href="#a5b690bc99d8eb5909b07f41e1d884dd7">More...</a><br/></td></tr>
<tr class="separator:a5b690bc99d8eb5909b07f41e1d884dd7 inherit pub_methods_classhazelcast_1_1client_1_1_distributed_object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae306777232ed783347fac3d7c0cbea29 inherit pub_methods_classhazelcast_1_1client_1_1_distributed_object"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhazelcast_1_1client_1_1_distributed_object.html#ae306777232ed783347fac3d7c0cbea29">destroy</a> ()</td></tr>
<tr class="memdesc:ae306777232ed783347fac3d7c0cbea29 inherit pub_methods_classhazelcast_1_1client_1_1_distributed_object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys this object cluster-wide.  <a href="#ae306777232ed783347fac3d7c0cbea29">More...</a><br/></td></tr>
<tr class="separator:ae306777232ed783347fac3d7c0cbea29 inherit pub_methods_classhazelcast_1_1client_1_1_distributed_object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b4b8d43d7cebf43547758c9ae99339c inherit pub_methods_classhazelcast_1_1client_1_1_distributed_object"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3b4b8d43d7cebf43547758c9ae99339c"></a>
virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhazelcast_1_1client_1_1_distributed_object.html#a3b4b8d43d7cebf43547758c9ae99339c">~DistributedObject</a> ()</td></tr>
<tr class="memdesc:a3b4b8d43d7cebf43547758c9ae99339c inherit pub_methods_classhazelcast_1_1client_1_1_distributed_object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor. <br/></td></tr>
<tr class="separator:a3b4b8d43d7cebf43547758c9ae99339c inherit pub_methods_classhazelcast_1_1client_1_1_distributed_object"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a3f921619afb86782bcf850c139aea9ed"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3f921619afb86782bcf850c139aea9ed"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>HazelcastClient</b></td></tr>
<tr class="separator:a3f921619afb86782bcf850c139aea9ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pro_methods_classhazelcast_1_1client_1_1_distributed_object"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_classhazelcast_1_1client_1_1_distributed_object')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="classhazelcast_1_1client_1_1_distributed_object.html">hazelcast::client::DistributedObject</a></td></tr>
<tr class="memitem:a49e1596648b5787075dd6bca74588b01 inherit pro_methods_classhazelcast_1_1client_1_1_distributed_object"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a49e1596648b5787075dd6bca74588b01"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhazelcast_1_1client_1_1_distributed_object.html#a49e1596648b5787075dd6bca74588b01">DistributedObject</a> (const std::string &amp;serviceName, const std::string &amp;objectName, spi::ClientContext *context)</td></tr>
<tr class="memdesc:a49e1596648b5787075dd6bca74588b01 inherit pro_methods_classhazelcast_1_1client_1_1_distributed_object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor. <br/></td></tr>
<tr class="separator:a49e1596648b5787075dd6bca74588b01 inherit pro_methods_classhazelcast_1_1client_1_1_distributed_object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0be7a69383e36e0cec6d9e1a497d131 inherit pro_methods_classhazelcast_1_1client_1_1_distributed_object"><td class="memItemLeft" align="right" valign="top">spi::ClientContext &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhazelcast_1_1client_1_1_distributed_object.html#ad0be7a69383e36e0cec6d9e1a497d131">getContext</a> ()</td></tr>
<tr class="separator:ad0be7a69383e36e0cec6d9e1a497d131 inherit pro_methods_classhazelcast_1_1client_1_1_distributed_object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1161b36a20bdaa613c9d61b05e81c817 inherit pro_methods_classhazelcast_1_1client_1_1_distributed_object"><td class="memTemplParams" colspan="2">template&lt;typename Response &gt; </td></tr>
<tr class="memitem:a1161b36a20bdaa613c9d61b05e81c817 inherit pro_methods_classhazelcast_1_1client_1_1_distributed_object"><td class="memTemplItemLeft" align="right" valign="top">boost::shared_ptr&lt; Response &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classhazelcast_1_1client_1_1_distributed_object.html#a1161b36a20bdaa613c9d61b05e81c817">invoke</a> (const impl::PortableRequest *request, int partitionId)</td></tr>
<tr class="memdesc:a1161b36a20bdaa613c9d61b05e81c817 inherit pro_methods_classhazelcast_1_1client_1_1_distributed_object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal API.  <a href="#a1161b36a20bdaa613c9d61b05e81c817">More...</a><br/></td></tr>
<tr class="separator:a1161b36a20bdaa613c9d61b05e81c817 inherit pro_methods_classhazelcast_1_1client_1_1_distributed_object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b8f8b80773ee29b0bb1771ececfed98 inherit pro_methods_classhazelcast_1_1client_1_1_distributed_object"><td class="memTemplParams" colspan="2">template&lt;typename Response &gt; </td></tr>
<tr class="memitem:a9b8f8b80773ee29b0bb1771ececfed98 inherit pro_methods_classhazelcast_1_1client_1_1_distributed_object"><td class="memTemplItemLeft" align="right" valign="top">boost::shared_ptr&lt; Response &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classhazelcast_1_1client_1_1_distributed_object.html#a9b8f8b80773ee29b0bb1771ececfed98">invoke</a> (const impl::PortableRequest *request)</td></tr>
<tr class="memdesc:a9b8f8b80773ee29b0bb1771ececfed98 inherit pro_methods_classhazelcast_1_1client_1_1_distributed_object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal API.  <a href="#a9b8f8b80773ee29b0bb1771ececfed98">More...</a><br/></td></tr>
<tr class="separator:a9b8f8b80773ee29b0bb1771ececfed98 inherit pro_methods_classhazelcast_1_1client_1_1_distributed_object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3a7241818c4291dd93250584f8d2952 inherit pro_methods_classhazelcast_1_1client_1_1_distributed_object"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhazelcast_1_1client_1_1_distributed_object.html#ac3a7241818c4291dd93250584f8d2952">listen</a> (const impl::PortableRequest *registrationRequest, int partitionId, impl::BaseEventHandler *handler)</td></tr>
<tr class="memdesc:ac3a7241818c4291dd93250584f8d2952 inherit pro_methods_classhazelcast_1_1client_1_1_distributed_object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal API.  <a href="#ac3a7241818c4291dd93250584f8d2952">More...</a><br/></td></tr>
<tr class="separator:ac3a7241818c4291dd93250584f8d2952 inherit pro_methods_classhazelcast_1_1client_1_1_distributed_object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b5b938cbc44bb712555474dd350c21e inherit pro_methods_classhazelcast_1_1client_1_1_distributed_object"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhazelcast_1_1client_1_1_distributed_object.html#a2b5b938cbc44bb712555474dd350c21e">listen</a> (const impl::PortableRequest *registrationRequest, impl::BaseEventHandler *handler)</td></tr>
<tr class="memdesc:a2b5b938cbc44bb712555474dd350c21e inherit pro_methods_classhazelcast_1_1client_1_1_distributed_object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal API.  <a href="#a2b5b938cbc44bb712555474dd350c21e">More...</a><br/></td></tr>
<tr class="separator:a2b5b938cbc44bb712555474dd350c21e inherit pro_methods_classhazelcast_1_1client_1_1_distributed_object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7842fa1472d63193822acfb9ab4a1b34 inherit pro_methods_classhazelcast_1_1client_1_1_distributed_object"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhazelcast_1_1client_1_1_distributed_object.html#a7842fa1472d63193822acfb9ab4a1b34">stopListening</a> (impl::BaseRemoveListenerRequest *request, const std::string &amp;registrationId)</td></tr>
<tr class="memdesc:a7842fa1472d63193822acfb9ab4a1b34 inherit pro_methods_classhazelcast_1_1client_1_1_distributed_object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal API.  <a href="#a7842fa1472d63193822acfb9ab4a1b34">More...</a><br/></td></tr>
<tr class="separator:a7842fa1472d63193822acfb9ab4a1b34 inherit pro_methods_classhazelcast_1_1client_1_1_distributed_object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8efd57d3aeb21387878dd90436d7f499 inherit pro_methods_classhazelcast_1_1client_1_1_distributed_object"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhazelcast_1_1client_1_1_distributed_object.html#a8efd57d3aeb21387878dd90436d7f499">getPartitionId</a> (const serialization::pimpl::Data &amp;key)</td></tr>
<tr class="memdesc:a8efd57d3aeb21387878dd90436d7f499 inherit pro_methods_classhazelcast_1_1client_1_1_distributed_object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal API.  <a href="#a8efd57d3aeb21387878dd90436d7f499">More...</a><br/></td></tr>
<tr class="separator:a8efd57d3aeb21387878dd90436d7f499 inherit pro_methods_classhazelcast_1_1client_1_1_distributed_object"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p><a class="el" href="classhazelcast_1_1client_1_1_i_count_down_latch.html" title="ICountDownLatch is a backed-up distributed alternative to the java.util.concurrent.CountDownLatch java.util.concurrent.CountDownLatch. ">ICountDownLatch</a> is a backed-up distributed alternative to the java.util.concurrent.CountDownLatch java.util.concurrent.CountDownLatch. </p>
<p><a class="el" href="classhazelcast_1_1client_1_1_i_count_down_latch.html" title="ICountDownLatch is a backed-up distributed alternative to the java.util.concurrent.CountDownLatch java.util.concurrent.CountDownLatch. ">ICountDownLatch</a> is a cluster-wide synchronization aid that allows one or more threads to wait until a set of operations being performed in other threads completes.</p>
<p>There are a few differences compared to the <a class="el" href="classhazelcast_1_1client_1_1_i_count_down_latch.html" title="ICountDownLatch is a backed-up distributed alternative to the java.util.concurrent.CountDownLatch java.util.concurrent.CountDownLatch. ">ICountDownLatch</a> : </p>
<ol>
<li>
the <a class="el" href="classhazelcast_1_1client_1_1_i_count_down_latch.html" title="ICountDownLatch is a backed-up distributed alternative to the java.util.concurrent.CountDownLatch java.util.concurrent.CountDownLatch. ">ICountDownLatch</a> count can be re-set using <a class="el" href="classhazelcast_1_1client_1_1_i_count_down_latch.html#abe33c0abc6d3ea0c8cee24f3bb851ad0" title="Sets the count to the given value if the current count is zero. ">trySetCount(int)</a> after a countdown has finished but not during an active count. This allows the same latch instance to be reused.  </li>
<li>
there is no <a class="el" href="classhazelcast_1_1client_1_1_i_count_down_latch.html#a082475738f0de687772ce0c18120ee54" title="Causes the current thread to wait until the latch has counted down to zero, an exception is thrown...">await()</a> method to do an unbound wait since this is undesirable in a distributed application: it can happen that for example a cluster is split or that the master and replica's all die. So in most cases it is best to configure an explicit timeout so have the ability to deal with these situations.  </li>
</ol>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a082475738f0de687772ce0c18120ee54"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool hazelcast::client::ICountDownLatch::await </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>timeoutInMillis</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Causes the current thread to wait until the latch has counted down to zero, an exception is thrown, or the specified waiting time elapses. </p>
<p>If the current count is zero then this method returns immediately with the value true.</p>
<p>If the current count is greater than zero then the current thread becomes disabled for thread scheduling purposes and lies dormant until one of five things happen: </p>
<ul>
<li>
The count reaches zero due to invocations of the <a class="el" href="classhazelcast_1_1client_1_1_i_count_down_latch.html#a0aa22b0764bfda816269cae74357c95b" title="Decrements the count of the latch, releasing all waiting threads if the count reaches zero...">countDown</a> method; </li>
<li>
This <a class="el" href="classhazelcast_1_1client_1_1_i_count_down_latch.html" title="ICountDownLatch is a backed-up distributed alternative to the java.util.concurrent.CountDownLatch java.util.concurrent.CountDownLatch. ">ICountDownLatch</a> instance is destroyed; </li>
<li>
The countdown owner becomes disconnected; </li>
<li>
Some other thread interrupts the current thread; or </li>
<li>
The specified waiting time elapses. </li>
</ul>
<p>If the count reaches zero then the method returns with the value true.</p>
<p>If the countdown owner becomes disconnected while waiting then MemberLeftException will be thrown. </p>
<p>If the current thread: </p>
<ul>
<li>
has its interrupted status set on entry to this method; or </li>
<li>
is interrupted while waiting, </li>
</ul>
<p>then InterruptedException is thrown and the current thread's interrupted status is cleared. </p>
<p>If the specified waiting time elapses then the value false is returned. If the time is less than or equal to zero, the method will not wait at all.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">timeoutInMillis</td><td>the maximum time to wait </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the count reached zero and false if the waiting time elapsed before the count reached zero </dd></dl>

</div>
</div>
<a class="anchor" id="a0aa22b0764bfda816269cae74357c95b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void hazelcast::client::ICountDownLatch::countDown </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Decrements the count of the latch, releasing all waiting threads if the count reaches zero. </p>
<p>If the current count is greater than zero then it is decremented. If the new count is zero: </p>
<ul>
<li>
All waiting threads are re-enabled for thread scheduling purposes </li>
</ul>
<p>If the current count equals zero then nothing happens. </p>

</div>
</div>
<a class="anchor" id="a25f9ae16b66a2c035389d5399cab911a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int hazelcast::client::ICountDownLatch::getCount </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the current count. </p>
<dl class="section return"><dt>Returns</dt><dd>current count </dd></dl>

</div>
</div>
<a class="anchor" id="abe33c0abc6d3ea0c8cee24f3bb851ad0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool hazelcast::client::ICountDownLatch::trySetCount </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>count</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the count to the given value if the current count is zero. </p>
<p>The calling cluster member becomes the owner of the countdown and is responsible for staying connected to the cluster until the count reaches zero. If the owner becomes disconnected before the count reaches zero: </p>
<ul>
<li>
Count will be set to zero; </li>
<li>
All awaiting threads will be thrown a MemberLeftException. </li>
</ul>
<p>If count is not zero then this method does nothing and returns false.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">count</td><td>the number of times <a class="el" href="classhazelcast_1_1client_1_1_i_count_down_latch.html#a0aa22b0764bfda816269cae74357c95b" title="Decrements the count of the latch, releasing all waiting threads if the count reaches zero...">countDown</a> must be invoked before threads can pass through <a class="el" href="classhazelcast_1_1client_1_1_i_count_down_latch.html#a082475738f0de687772ce0c18120ee54" title="Causes the current thread to wait until the latch has counted down to zero, an exception is thrown...">await</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the new count was set or false if the current count is not zero </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">IllegalArgumentException</td><td>if count is negative </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>hazelcast/include/hazelcast/client/<a class="el" href="_i_count_down_latch_8h_source.html">ICountDownLatch.h</a></li>
<li>hazelcast/src/hazelcast/client/ICountDownLatch.cpp</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Thu May 15 2014 16:20:22 for Hazelcast C++ Client by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.5
</small></address>
</body>
</html>
