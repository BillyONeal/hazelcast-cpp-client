<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.5"/>
<title>Hazelcast C++ Client: hazelcast::client::IMap&lt; K, V &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Hazelcast C++ Client
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.5 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>hazelcast</b></li><li class="navelem"><b>client</b></li><li class="navelem"><a class="el" href="classhazelcast_1_1client_1_1_i_map.html">IMap</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classhazelcast_1_1client_1_1_i_map-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">hazelcast::client::IMap&lt; K, V &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Concurrent, distributed, observable and queryable map client.  
 <a href="classhazelcast_1_1client_1_1_i_map.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_i_map_8h_source.html">IMap.h</a>&gt;</code></p>
<div id="dynsection-0" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-0-trigger" src="closed.png" alt="+"/> Inheritance diagram for hazelcast::client::IMap&lt; K, V &gt;:</div>
<div id="dynsection-0-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-0-content" class="dyncontent" style="display:none;">
 <div class="center">
  <img src="classhazelcast_1_1client_1_1_i_map.png" usemap="#hazelcast::client::IMap&lt; K, V &gt;_map" alt=""/>
  <map id="hazelcast::client::IMap&lt; K, V &gt;_map" name="hazelcast::client::IMap&lt; K, V &gt;_map">
<area href="classhazelcast_1_1client_1_1_distributed_object.html" title="Base class for all distributed objects. " alt="hazelcast::client::DistributedObject" shape="rect" coords="0,0,204,24"/>
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a170cef2114ceabeaa01b1092c82cc046"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhazelcast_1_1client_1_1_i_map.html#a170cef2114ceabeaa01b1092c82cc046">containsKey</a> (const K &amp;key)</td></tr>
<tr class="memdesc:a170cef2114ceabeaa01b1092c82cc046"><td class="mdescLeft">&#160;</td><td class="mdescRight">check if this map contains key.  <a href="#a170cef2114ceabeaa01b1092c82cc046">More...</a><br/></td></tr>
<tr class="separator:a170cef2114ceabeaa01b1092c82cc046"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace9b22183aa574e350b58b6f36836156"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhazelcast_1_1client_1_1_i_map.html#ace9b22183aa574e350b58b6f36836156">containsValue</a> (const V &amp;value)</td></tr>
<tr class="memdesc:ace9b22183aa574e350b58b6f36836156"><td class="mdescLeft">&#160;</td><td class="mdescRight">check if this map contains value.  <a href="#ace9b22183aa574e350b58b6f36836156">More...</a><br/></td></tr>
<tr class="separator:ace9b22183aa574e350b58b6f36836156"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba1680c329399db804ca1c150332ef39"><td class="memItemLeft" align="right" valign="top">boost::shared_ptr&lt; V &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhazelcast_1_1client_1_1_i_map.html#aba1680c329399db804ca1c150332ef39">get</a> (const K &amp;key)</td></tr>
<tr class="memdesc:aba1680c329399db804ca1c150332ef39"><td class="mdescLeft">&#160;</td><td class="mdescRight">get the value.  <a href="#aba1680c329399db804ca1c150332ef39">More...</a><br/></td></tr>
<tr class="separator:aba1680c329399db804ca1c150332ef39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8cb0ccd484b05987e51cbe4279feeacc"><td class="memItemLeft" align="right" valign="top">boost::shared_ptr&lt; V &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhazelcast_1_1client_1_1_i_map.html#a8cb0ccd484b05987e51cbe4279feeacc">put</a> (const K &amp;key, const V &amp;value)</td></tr>
<tr class="memdesc:a8cb0ccd484b05987e51cbe4279feeacc"><td class="mdescLeft">&#160;</td><td class="mdescRight">put new entry into map.  <a href="#a8cb0ccd484b05987e51cbe4279feeacc">More...</a><br/></td></tr>
<tr class="separator:a8cb0ccd484b05987e51cbe4279feeacc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43dff4b730688415ef98e6496af2131d"><td class="memItemLeft" align="right" valign="top">boost::shared_ptr&lt; V &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhazelcast_1_1client_1_1_i_map.html#a43dff4b730688415ef98e6496af2131d">remove</a> (const K &amp;key)</td></tr>
<tr class="memdesc:a43dff4b730688415ef98e6496af2131d"><td class="mdescLeft">&#160;</td><td class="mdescRight">remove entry form map  <a href="#a43dff4b730688415ef98e6496af2131d">More...</a><br/></td></tr>
<tr class="separator:a43dff4b730688415ef98e6496af2131d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab64154342e35f53d72c4401e920b085a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhazelcast_1_1client_1_1_i_map.html#ab64154342e35f53d72c4401e920b085a">remove</a> (const K &amp;key, const V &amp;value)</td></tr>
<tr class="memdesc:ab64154342e35f53d72c4401e920b085a"><td class="mdescLeft">&#160;</td><td class="mdescRight">removes entry from map if there is an entry with same key and value.  <a href="#ab64154342e35f53d72c4401e920b085a">More...</a><br/></td></tr>
<tr class="separator:ab64154342e35f53d72c4401e920b085a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e60c0902de0a8cfb92affdd1881df8d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhazelcast_1_1client_1_1_i_map.html#a2e60c0902de0a8cfb92affdd1881df8d">deleteEntry</a> (const K &amp;key)</td></tr>
<tr class="memdesc:a2e60c0902de0a8cfb92affdd1881df8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">removes entry from map.  <a href="#a2e60c0902de0a8cfb92affdd1881df8d">More...</a><br/></td></tr>
<tr class="separator:a2e60c0902de0a8cfb92affdd1881df8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19bd84103de37bc20a0a169cd13b7e89"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a19bd84103de37bc20a0a169cd13b7e89"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhazelcast_1_1client_1_1_i_map.html#a19bd84103de37bc20a0a169cd13b7e89">flush</a> ()</td></tr>
<tr class="memdesc:a19bd84103de37bc20a0a169cd13b7e89"><td class="mdescLeft">&#160;</td><td class="mdescRight">If this map has a MapStore this method flushes all the local dirty entries by calling MapStore.storeAll() and/or MapStore.deleteAll() <br/></td></tr>
<tr class="separator:a19bd84103de37bc20a0a169cd13b7e89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafa1adff6d21dcf64ddae18b4edd01b0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhazelcast_1_1client_1_1_i_map.html#aafa1adff6d21dcf64ddae18b4edd01b0">tryRemove</a> (const K &amp;key, long timeoutInMillis)</td></tr>
<tr class="memdesc:aafa1adff6d21dcf64ddae18b4edd01b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Asynchronously gets the given key.  <a href="#aafa1adff6d21dcf64ddae18b4edd01b0">More...</a><br/></td></tr>
<tr class="separator:aafa1adff6d21dcf64ddae18b4edd01b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb32c9b7337c472b6e9093a5545c70dd"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhazelcast_1_1client_1_1_i_map.html#afb32c9b7337c472b6e9093a5545c70dd">tryPut</a> (const K &amp;key, const V &amp;value, long timeoutInMillis)</td></tr>
<tr class="memdesc:afb32c9b7337c472b6e9093a5545c70dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tries to put the given key, value into this map within specified timeout value.  <a href="#afb32c9b7337c472b6e9093a5545c70dd">More...</a><br/></td></tr>
<tr class="separator:afb32c9b7337c472b6e9093a5545c70dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8860b7349d09e9a890ae0ed856863736"><td class="memItemLeft" align="right" valign="top">boost::shared_ptr&lt; V &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhazelcast_1_1client_1_1_i_map.html#a8860b7349d09e9a890ae0ed856863736">put</a> (const K &amp;key, const V &amp;value, long ttlInMillis)</td></tr>
<tr class="memdesc:a8860b7349d09e9a890ae0ed856863736"><td class="mdescLeft">&#160;</td><td class="mdescRight">Puts an entry into this map with a given ttl (time to live) value.  <a href="#a8860b7349d09e9a890ae0ed856863736">More...</a><br/></td></tr>
<tr class="separator:a8860b7349d09e9a890ae0ed856863736"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28a84b2c9f14d55b40b26d28dd829bcd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhazelcast_1_1client_1_1_i_map.html#a28a84b2c9f14d55b40b26d28dd829bcd">putTransient</a> (const K &amp;key, const V &amp;value, long ttlInMillis)</td></tr>
<tr class="memdesc:a28a84b2c9f14d55b40b26d28dd829bcd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as put(K, V, long, TimeUnit) but MapStore, if defined, will not be called to store/persist the entry.  <a href="#a28a84b2c9f14d55b40b26d28dd829bcd">More...</a><br/></td></tr>
<tr class="separator:a28a84b2c9f14d55b40b26d28dd829bcd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15ce0a97c73b5f3af6fd83beec865990"><td class="memItemLeft" align="right" valign="top">boost::shared_ptr&lt; V &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhazelcast_1_1client_1_1_i_map.html#a15ce0a97c73b5f3af6fd83beec865990">putIfAbsent</a> (const K &amp;key, const V &amp;value)</td></tr>
<tr class="memdesc:a15ce0a97c73b5f3af6fd83beec865990"><td class="mdescLeft">&#160;</td><td class="mdescRight">Puts an entry into this map, if the specified key is not already associated with a value.  <a href="#a15ce0a97c73b5f3af6fd83beec865990">More...</a><br/></td></tr>
<tr class="separator:a15ce0a97c73b5f3af6fd83beec865990"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea8f5740ecb60d3c644966f29e79f9b3"><td class="memItemLeft" align="right" valign="top">boost::shared_ptr&lt; V &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhazelcast_1_1client_1_1_i_map.html#aea8f5740ecb60d3c644966f29e79f9b3">putIfAbsent</a> (const K &amp;key, const V &amp;value, long ttlInMillis)</td></tr>
<tr class="memdesc:aea8f5740ecb60d3c644966f29e79f9b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Puts an entry into this map with a given ttl (time to live) value if the specified key is not already associated with a value.  <a href="#aea8f5740ecb60d3c644966f29e79f9b3">More...</a><br/></td></tr>
<tr class="separator:aea8f5740ecb60d3c644966f29e79f9b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a027c6346d0cbdfbea6800e12f5c1e02c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhazelcast_1_1client_1_1_i_map.html#a027c6346d0cbdfbea6800e12f5c1e02c">replace</a> (const K &amp;key, const V &amp;oldValue, const V &amp;newValue)</td></tr>
<tr class="memdesc:a027c6346d0cbdfbea6800e12f5c1e02c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces the entry for a key only if currently mapped to a given value.  <a href="#a027c6346d0cbdfbea6800e12f5c1e02c">More...</a><br/></td></tr>
<tr class="separator:a027c6346d0cbdfbea6800e12f5c1e02c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad590b52ee71f28f454d0b562d518f795"><td class="memItemLeft" align="right" valign="top">boost::shared_ptr&lt; V &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhazelcast_1_1client_1_1_i_map.html#ad590b52ee71f28f454d0b562d518f795">replace</a> (const K &amp;key, const V &amp;value)</td></tr>
<tr class="memdesc:ad590b52ee71f28f454d0b562d518f795"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces the entry for a key only if currently mapped to some value.  <a href="#ad590b52ee71f28f454d0b562d518f795">More...</a><br/></td></tr>
<tr class="separator:ad590b52ee71f28f454d0b562d518f795"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7661edfc60b8ae71ca420a25af350c2b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhazelcast_1_1client_1_1_i_map.html#a7661edfc60b8ae71ca420a25af350c2b">set</a> (const K &amp;key, const V &amp;value, long ttl)</td></tr>
<tr class="memdesc:a7661edfc60b8ae71ca420a25af350c2b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Puts an entry into this map.  <a href="#a7661edfc60b8ae71ca420a25af350c2b">More...</a><br/></td></tr>
<tr class="separator:a7661edfc60b8ae71ca420a25af350c2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fd16e702dcecd6275b77d215a799ef6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhazelcast_1_1client_1_1_i_map.html#a3fd16e702dcecd6275b77d215a799ef6">lock</a> (const K &amp;key)</td></tr>
<tr class="memdesc:a3fd16e702dcecd6275b77d215a799ef6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Acquires the lock for the specified key.  <a href="#a3fd16e702dcecd6275b77d215a799ef6">More...</a><br/></td></tr>
<tr class="separator:a3fd16e702dcecd6275b77d215a799ef6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a669e64771b5fe1e8c50421708182d68a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhazelcast_1_1client_1_1_i_map.html#a669e64771b5fe1e8c50421708182d68a">lock</a> (const K &amp;key, long leaseTime)</td></tr>
<tr class="memdesc:a669e64771b5fe1e8c50421708182d68a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Acquires the lock for the specified key for the specified lease time.  <a href="#a669e64771b5fe1e8c50421708182d68a">More...</a><br/></td></tr>
<tr class="separator:a669e64771b5fe1e8c50421708182d68a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf89902b2b1cd6a697d3d83de4d2f591"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhazelcast_1_1client_1_1_i_map.html#abf89902b2b1cd6a697d3d83de4d2f591">isLocked</a> (const K &amp;key)</td></tr>
<tr class="memdesc:abf89902b2b1cd6a697d3d83de4d2f591"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks the lock for the specified key.  <a href="#abf89902b2b1cd6a697d3d83de4d2f591">More...</a><br/></td></tr>
<tr class="separator:abf89902b2b1cd6a697d3d83de4d2f591"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a264f894e0ab8ee3af07c963e366f3334"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhazelcast_1_1client_1_1_i_map.html#a264f894e0ab8ee3af07c963e366f3334">tryLock</a> (const K &amp;key)</td></tr>
<tr class="memdesc:a264f894e0ab8ee3af07c963e366f3334"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tries to acquire the lock for the specified key.  <a href="#a264f894e0ab8ee3af07c963e366f3334">More...</a><br/></td></tr>
<tr class="separator:a264f894e0ab8ee3af07c963e366f3334"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:accfd6a35fd9fdb6d0f19385b0998cfa9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhazelcast_1_1client_1_1_i_map.html#accfd6a35fd9fdb6d0f19385b0998cfa9">tryLock</a> (const K &amp;key, long timeInMillis)</td></tr>
<tr class="memdesc:accfd6a35fd9fdb6d0f19385b0998cfa9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tries to acquire the lock for the specified key.  <a href="#accfd6a35fd9fdb6d0f19385b0998cfa9">More...</a><br/></td></tr>
<tr class="separator:accfd6a35fd9fdb6d0f19385b0998cfa9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7a129c364501f111fadc943989049c2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhazelcast_1_1client_1_1_i_map.html#ac7a129c364501f111fadc943989049c2">unlock</a> (const K &amp;key)</td></tr>
<tr class="memdesc:ac7a129c364501f111fadc943989049c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Releases the lock for the specified key.  <a href="#ac7a129c364501f111fadc943989049c2">More...</a><br/></td></tr>
<tr class="separator:ac7a129c364501f111fadc943989049c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4dd49115922a7061ba027b992878aa52"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhazelcast_1_1client_1_1_i_map.html#a4dd49115922a7061ba027b992878aa52">forceUnlock</a> (const K &amp;key)</td></tr>
<tr class="memdesc:a4dd49115922a7061ba027b992878aa52"><td class="mdescLeft">&#160;</td><td class="mdescRight">Releases the lock for the specified key regardless of the lock owner.  <a href="#a4dd49115922a7061ba027b992878aa52">More...</a><br/></td></tr>
<tr class="separator:a4dd49115922a7061ba027b992878aa52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae615c0210313b3adf012adb5c660d869"><td class="memTemplParams" colspan="2">template&lt;typename MapInterceptor &gt; </td></tr>
<tr class="memitem:ae615c0210313b3adf012adb5c660d869"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classhazelcast_1_1client_1_1_i_map.html#ae615c0210313b3adf012adb5c660d869">addInterceptor</a> (MapInterceptor &amp;interceptor)</td></tr>
<tr class="memdesc:ae615c0210313b3adf012adb5c660d869"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds an interceptor for this map.  <a href="#ae615c0210313b3adf012adb5c660d869">More...</a><br/></td></tr>
<tr class="separator:ae615c0210313b3adf012adb5c660d869"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a4b134bc0a6938d07ba3066b9db3cab"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhazelcast_1_1client_1_1_i_map.html#a7a4b134bc0a6938d07ba3066b9db3cab">removeInterceptor</a> (const std::string &amp;id)</td></tr>
<tr class="memdesc:a7a4b134bc0a6938d07ba3066b9db3cab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the given interceptor for this map.  <a href="#a7a4b134bc0a6938d07ba3066b9db3cab">More...</a><br/></td></tr>
<tr class="separator:a7a4b134bc0a6938d07ba3066b9db3cab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a762e0fc1866d40540391e0b18104e37b"><td class="memTemplParams" colspan="2">template&lt;typename L &gt; </td></tr>
<tr class="memitem:a762e0fc1866d40540391e0b18104e37b"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classhazelcast_1_1client_1_1_i_map.html#a762e0fc1866d40540391e0b18104e37b">addEntryListener</a> (L &amp;listener, bool includeValue)</td></tr>
<tr class="memdesc:a762e0fc1866d40540391e0b18104e37b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds an entry listener for this map.  <a href="#a762e0fc1866d40540391e0b18104e37b">More...</a><br/></td></tr>
<tr class="separator:a762e0fc1866d40540391e0b18104e37b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f632026d7cf4069ddb6ab8212a7e532"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhazelcast_1_1client_1_1_i_map.html#a7f632026d7cf4069ddb6ab8212a7e532">removeEntryListener</a> (const std::string &amp;registrationId)</td></tr>
<tr class="memdesc:a7f632026d7cf4069ddb6ab8212a7e532"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the specified entry listener Returns silently if there is no such listener added before.  <a href="#a7f632026d7cf4069ddb6ab8212a7e532">More...</a><br/></td></tr>
<tr class="separator:a7f632026d7cf4069ddb6ab8212a7e532"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a337fc469db87ddde7c5abe1cb32b9a0c"><td class="memTemplParams" colspan="2">template&lt;typename L &gt; </td></tr>
<tr class="memitem:a337fc469db87ddde7c5abe1cb32b9a0c"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classhazelcast_1_1client_1_1_i_map.html#a337fc469db87ddde7c5abe1cb32b9a0c">addEntryListener</a> (L &amp;listener, const K &amp;key, bool includeValue)</td></tr>
<tr class="memdesc:a337fc469db87ddde7c5abe1cb32b9a0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds the specified entry listener for the specified key.  <a href="#a337fc469db87ddde7c5abe1cb32b9a0c">More...</a><br/></td></tr>
<tr class="separator:a337fc469db87ddde7c5abe1cb32b9a0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f2b7d543db528e24e90848e60129f6d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classhazelcast_1_1client_1_1_entry_view.html">EntryView</a>&lt; K, V &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhazelcast_1_1client_1_1_i_map.html#a9f2b7d543db528e24e90848e60129f6d">getEntryView</a> (const K &amp;key)</td></tr>
<tr class="memdesc:a9f2b7d543db528e24e90848e60129f6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds an continuous entry listener for this map.  <a href="#a9f2b7d543db528e24e90848e60129f6d">More...</a><br/></td></tr>
<tr class="separator:a9f2b7d543db528e24e90848e60129f6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a998d5cb825215da4452dcfba68a44693"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhazelcast_1_1client_1_1_i_map.html#a998d5cb825215da4452dcfba68a44693">evict</a> (const K &amp;key)</td></tr>
<tr class="memdesc:a998d5cb825215da4452dcfba68a44693"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evicts the specified key from this map.  <a href="#a998d5cb825215da4452dcfba68a44693">More...</a><br/></td></tr>
<tr class="separator:a998d5cb825215da4452dcfba68a44693"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a705cb50f8bb69cb1e4a41b0ae295b185"><td class="memItemLeft" align="right" valign="top">std::vector&lt; K &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhazelcast_1_1client_1_1_i_map.html#a705cb50f8bb69cb1e4a41b0ae295b185">keySet</a> ()</td></tr>
<tr class="memdesc:a705cb50f8bb69cb1e4a41b0ae295b185"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a vector clone of the keys contained in this map.  <a href="#a705cb50f8bb69cb1e4a41b0ae295b185">More...</a><br/></td></tr>
<tr class="separator:a705cb50f8bb69cb1e4a41b0ae295b185"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7209df2551c29105c6d261f720d1c491"><td class="memItemLeft" align="right" valign="top">std::map&lt; K, V &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhazelcast_1_1client_1_1_i_map.html#a7209df2551c29105c6d261f720d1c491">getAll</a> (const std::set&lt; K &gt; &amp;keys)</td></tr>
<tr class="memdesc:a7209df2551c29105c6d261f720d1c491"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the entries for the given keys.  <a href="#a7209df2551c29105c6d261f720d1c491">More...</a><br/></td></tr>
<tr class="separator:a7209df2551c29105c6d261f720d1c491"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e8c93cd26956bb02f280cabb41d4c65"><td class="memItemLeft" align="right" valign="top">std::vector&lt; V &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhazelcast_1_1client_1_1_i_map.html#a3e8c93cd26956bb02f280cabb41d4c65">values</a> ()</td></tr>
<tr class="memdesc:a3e8c93cd26956bb02f280cabb41d4c65"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a vector clone of the values contained in this map.  <a href="#a3e8c93cd26956bb02f280cabb41d4c65">More...</a><br/></td></tr>
<tr class="separator:a3e8c93cd26956bb02f280cabb41d4c65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77529aa3ed118517d59357362f4a049c"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::pair&lt; K, V &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhazelcast_1_1client_1_1_i_map.html#a77529aa3ed118517d59357362f4a049c">entrySet</a> ()</td></tr>
<tr class="memdesc:a77529aa3ed118517d59357362f4a049c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a std::vector&lt; std::pair&lt;K, V&gt; &gt; clone of the mappings contained in this map.  <a href="#a77529aa3ed118517d59357362f4a049c">More...</a><br/></td></tr>
<tr class="separator:a77529aa3ed118517d59357362f4a049c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b2e5e447b66b769d7a4786783bc5719"><td class="memItemLeft" align="right" valign="top">std::vector&lt; K &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhazelcast_1_1client_1_1_i_map.html#a9b2e5e447b66b769d7a4786783bc5719">keySet</a> (const std::string &amp;sql)</td></tr>
<tr class="memdesc:a9b2e5e447b66b769d7a4786783bc5719"><td class="mdescLeft">&#160;</td><td class="mdescRight">Queries the map based on the specified sql predicate and returns the keys of matching entries.  <a href="#a9b2e5e447b66b769d7a4786783bc5719">More...</a><br/></td></tr>
<tr class="separator:a9b2e5e447b66b769d7a4786783bc5719"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a296ae915e85d7376c4629ab1e4686662"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::pair&lt; K, V &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhazelcast_1_1client_1_1_i_map.html#a296ae915e85d7376c4629ab1e4686662">entrySet</a> (const std::string &amp;sql)</td></tr>
<tr class="memdesc:a296ae915e85d7376c4629ab1e4686662"><td class="mdescLeft">&#160;</td><td class="mdescRight">Queries the map based on the specified sql predicate and returns the matching entries.  <a href="#a296ae915e85d7376c4629ab1e4686662">More...</a><br/></td></tr>
<tr class="separator:a296ae915e85d7376c4629ab1e4686662"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5cd74d9d42d8c4f03c1ba3501c3043d"><td class="memItemLeft" align="right" valign="top">std::vector&lt; V &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhazelcast_1_1client_1_1_i_map.html#ad5cd74d9d42d8c4f03c1ba3501c3043d">values</a> (const std::string &amp;sql)</td></tr>
<tr class="memdesc:ad5cd74d9d42d8c4f03c1ba3501c3043d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Queries the map based on the specified predicate and returns the values of matching entries.  <a href="#ad5cd74d9d42d8c4f03c1ba3501c3043d">More...</a><br/></td></tr>
<tr class="separator:ad5cd74d9d42d8c4f03c1ba3501c3043d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8cdcb167ddbbbbf3d2339e488804f0c0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhazelcast_1_1client_1_1_i_map.html#a8cdcb167ddbbbbf3d2339e488804f0c0">addIndex</a> (const std::string &amp;attribute, bool ordered)</td></tr>
<tr class="memdesc:a8cdcb167ddbbbbf3d2339e488804f0c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds an index to this map for the specified entries so that queries can run faster.  <a href="#a8cdcb167ddbbbbf3d2339e488804f0c0">More...</a><br/></td></tr>
<tr class="separator:a8cdcb167ddbbbbf3d2339e488804f0c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f9de0e8c5b65dbc96410125a5167f15"><td class="memTemplParams" colspan="2">template&lt;typename ResultType , typename EntryProcessor &gt; </td></tr>
<tr class="memitem:a4f9de0e8c5b65dbc96410125a5167f15"><td class="memTemplItemLeft" align="right" valign="top">ResultType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classhazelcast_1_1client_1_1_i_map.html#a4f9de0e8c5b65dbc96410125a5167f15">executeOnKey</a> (const K &amp;key, EntryProcessor &amp;entryProcessor)</td></tr>
<tr class="memdesc:a4f9de0e8c5b65dbc96410125a5167f15"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the user defined EntryProcessor to the entry mapped by the key.  <a href="#a4f9de0e8c5b65dbc96410125a5167f15">More...</a><br/></td></tr>
<tr class="separator:a4f9de0e8c5b65dbc96410125a5167f15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1825dd18743a360e3dbf5b491b65808"><td class="memTemplParams" colspan="2">template&lt;typename ResultType , typename EntryProcessor &gt; </td></tr>
<tr class="memitem:ad1825dd18743a360e3dbf5b491b65808"><td class="memTemplItemLeft" align="right" valign="top">std::map&lt; K, ResultType &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classhazelcast_1_1client_1_1_i_map.html#ad1825dd18743a360e3dbf5b491b65808">executeOnEntries</a> (EntryProcessor &amp;entryProcessor)</td></tr>
<tr class="memdesc:ad1825dd18743a360e3dbf5b491b65808"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the user defined EntryProcessor to the entry mapped by the key with specified ExecutionCallback to listen event status and returns immediately.  <a href="#ad1825dd18743a360e3dbf5b491b65808">More...</a><br/></td></tr>
<tr class="separator:ad1825dd18743a360e3dbf5b491b65808"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a809bccb891ae0086fde856051ec4637d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhazelcast_1_1client_1_1_i_map.html#a809bccb891ae0086fde856051ec4637d">set</a> (const K &amp;key, const V &amp;value)</td></tr>
<tr class="memdesc:a809bccb891ae0086fde856051ec4637d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the user defined EntryProcessor to the entries in the map which satisfies provided predicate.  <a href="#a809bccb891ae0086fde856051ec4637d">More...</a><br/></td></tr>
<tr class="separator:a809bccb891ae0086fde856051ec4637d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60b5bf7ac909ca4df929bb629ecd7ea4"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhazelcast_1_1client_1_1_i_map.html#a60b5bf7ac909ca4df929bb629ecd7ea4">size</a> ()</td></tr>
<tr class="memdesc:a60b5bf7ac909ca4df929bb629ecd7ea4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of key-value mappings in this map.  <a href="#a60b5bf7ac909ca4df929bb629ecd7ea4">More...</a><br/></td></tr>
<tr class="separator:a60b5bf7ac909ca4df929bb629ecd7ea4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fe482267adc581fbf06c19395e24b5d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhazelcast_1_1client_1_1_i_map.html#a2fe482267adc581fbf06c19395e24b5d">isEmpty</a> ()</td></tr>
<tr class="memdesc:a2fe482267adc581fbf06c19395e24b5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>true</code> if this map contains no key-value mappings.  <a href="#a2fe482267adc581fbf06c19395e24b5d">More...</a><br/></td></tr>
<tr class="separator:a2fe482267adc581fbf06c19395e24b5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2470be3eba624eaee105fe121f24378"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhazelcast_1_1client_1_1_i_map.html#ac2470be3eba624eaee105fe121f24378">putAll</a> (const std::map&lt; K, V &gt; &amp;m)</td></tr>
<tr class="memdesc:ac2470be3eba624eaee105fe121f24378"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies all of the mappings from the specified map to this map (optional operation).  <a href="#ac2470be3eba624eaee105fe121f24378">More...</a><br/></td></tr>
<tr class="separator:ac2470be3eba624eaee105fe121f24378"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7f66084e434121130a1d465ba5ade05"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhazelcast_1_1client_1_1_i_map.html#ac7f66084e434121130a1d465ba5ade05">clear</a> ()</td></tr>
<tr class="memdesc:ac7f66084e434121130a1d465ba5ade05"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes all of the mappings from this map (optional operation).  <a href="#ac7f66084e434121130a1d465ba5ade05">More...</a><br/></td></tr>
<tr class="separator:ac7f66084e434121130a1d465ba5ade05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classhazelcast_1_1client_1_1_distributed_object"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classhazelcast_1_1client_1_1_distributed_object')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classhazelcast_1_1client_1_1_distributed_object.html">hazelcast::client::DistributedObject</a></td></tr>
<tr class="memitem:a1990ab399703e9e977f82e148a66e579 inherit pub_methods_classhazelcast_1_1client_1_1_distributed_object"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1990ab399703e9e977f82e148a66e579"></a>
const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhazelcast_1_1client_1_1_distributed_object.html#a1990ab399703e9e977f82e148a66e579">getServiceName</a> () const </td></tr>
<tr class="memdesc:a1990ab399703e9e977f82e148a66e579 inherit pub_methods_classhazelcast_1_1client_1_1_distributed_object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the service name for this object. <br/></td></tr>
<tr class="separator:a1990ab399703e9e977f82e148a66e579 inherit pub_methods_classhazelcast_1_1client_1_1_distributed_object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b690bc99d8eb5909b07f41e1d884dd7 inherit pub_methods_classhazelcast_1_1client_1_1_distributed_object"><td class="memItemLeft" align="right" valign="top">const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhazelcast_1_1client_1_1_distributed_object.html#a5b690bc99d8eb5909b07f41e1d884dd7">getName</a> () const </td></tr>
<tr class="memdesc:a5b690bc99d8eb5909b07f41e1d884dd7 inherit pub_methods_classhazelcast_1_1client_1_1_distributed_object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the unique name for this <a class="el" href="classhazelcast_1_1client_1_1_distributed_object.html" title="Base class for all distributed objects. ">DistributedObject</a>.  <a href="#a5b690bc99d8eb5909b07f41e1d884dd7">More...</a><br/></td></tr>
<tr class="separator:a5b690bc99d8eb5909b07f41e1d884dd7 inherit pub_methods_classhazelcast_1_1client_1_1_distributed_object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae306777232ed783347fac3d7c0cbea29 inherit pub_methods_classhazelcast_1_1client_1_1_distributed_object"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhazelcast_1_1client_1_1_distributed_object.html#ae306777232ed783347fac3d7c0cbea29">destroy</a> ()</td></tr>
<tr class="memdesc:ae306777232ed783347fac3d7c0cbea29 inherit pub_methods_classhazelcast_1_1client_1_1_distributed_object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys this object cluster-wide.  <a href="#ae306777232ed783347fac3d7c0cbea29">More...</a><br/></td></tr>
<tr class="separator:ae306777232ed783347fac3d7c0cbea29 inherit pub_methods_classhazelcast_1_1client_1_1_distributed_object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b4b8d43d7cebf43547758c9ae99339c inherit pub_methods_classhazelcast_1_1client_1_1_distributed_object"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3b4b8d43d7cebf43547758c9ae99339c"></a>
virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhazelcast_1_1client_1_1_distributed_object.html#a3b4b8d43d7cebf43547758c9ae99339c">~DistributedObject</a> ()</td></tr>
<tr class="memdesc:a3b4b8d43d7cebf43547758c9ae99339c inherit pub_methods_classhazelcast_1_1client_1_1_distributed_object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor. <br/></td></tr>
<tr class="separator:a3b4b8d43d7cebf43547758c9ae99339c inherit pub_methods_classhazelcast_1_1client_1_1_distributed_object"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a3f921619afb86782bcf850c139aea9ed"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3f921619afb86782bcf850c139aea9ed"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>HazelcastClient</b></td></tr>
<tr class="separator:a3f921619afb86782bcf850c139aea9ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pro_methods_classhazelcast_1_1client_1_1_distributed_object"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_classhazelcast_1_1client_1_1_distributed_object')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="classhazelcast_1_1client_1_1_distributed_object.html">hazelcast::client::DistributedObject</a></td></tr>
<tr class="memitem:a49e1596648b5787075dd6bca74588b01 inherit pro_methods_classhazelcast_1_1client_1_1_distributed_object"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a49e1596648b5787075dd6bca74588b01"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhazelcast_1_1client_1_1_distributed_object.html#a49e1596648b5787075dd6bca74588b01">DistributedObject</a> (const std::string &amp;serviceName, const std::string &amp;objectName, spi::ClientContext *context)</td></tr>
<tr class="memdesc:a49e1596648b5787075dd6bca74588b01 inherit pro_methods_classhazelcast_1_1client_1_1_distributed_object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor. <br/></td></tr>
<tr class="separator:a49e1596648b5787075dd6bca74588b01 inherit pro_methods_classhazelcast_1_1client_1_1_distributed_object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0be7a69383e36e0cec6d9e1a497d131 inherit pro_methods_classhazelcast_1_1client_1_1_distributed_object"><td class="memItemLeft" align="right" valign="top">spi::ClientContext &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhazelcast_1_1client_1_1_distributed_object.html#ad0be7a69383e36e0cec6d9e1a497d131">getContext</a> ()</td></tr>
<tr class="separator:ad0be7a69383e36e0cec6d9e1a497d131 inherit pro_methods_classhazelcast_1_1client_1_1_distributed_object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1161b36a20bdaa613c9d61b05e81c817 inherit pro_methods_classhazelcast_1_1client_1_1_distributed_object"><td class="memTemplParams" colspan="2">template&lt;typename Response &gt; </td></tr>
<tr class="memitem:a1161b36a20bdaa613c9d61b05e81c817 inherit pro_methods_classhazelcast_1_1client_1_1_distributed_object"><td class="memTemplItemLeft" align="right" valign="top">boost::shared_ptr&lt; Response &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classhazelcast_1_1client_1_1_distributed_object.html#a1161b36a20bdaa613c9d61b05e81c817">invoke</a> (const impl::PortableRequest *request, int partitionId)</td></tr>
<tr class="memdesc:a1161b36a20bdaa613c9d61b05e81c817 inherit pro_methods_classhazelcast_1_1client_1_1_distributed_object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal API.  <a href="#a1161b36a20bdaa613c9d61b05e81c817">More...</a><br/></td></tr>
<tr class="separator:a1161b36a20bdaa613c9d61b05e81c817 inherit pro_methods_classhazelcast_1_1client_1_1_distributed_object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b8f8b80773ee29b0bb1771ececfed98 inherit pro_methods_classhazelcast_1_1client_1_1_distributed_object"><td class="memTemplParams" colspan="2">template&lt;typename Response &gt; </td></tr>
<tr class="memitem:a9b8f8b80773ee29b0bb1771ececfed98 inherit pro_methods_classhazelcast_1_1client_1_1_distributed_object"><td class="memTemplItemLeft" align="right" valign="top">boost::shared_ptr&lt; Response &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classhazelcast_1_1client_1_1_distributed_object.html#a9b8f8b80773ee29b0bb1771ececfed98">invoke</a> (const impl::PortableRequest *request)</td></tr>
<tr class="memdesc:a9b8f8b80773ee29b0bb1771ececfed98 inherit pro_methods_classhazelcast_1_1client_1_1_distributed_object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal API.  <a href="#a9b8f8b80773ee29b0bb1771ececfed98">More...</a><br/></td></tr>
<tr class="separator:a9b8f8b80773ee29b0bb1771ececfed98 inherit pro_methods_classhazelcast_1_1client_1_1_distributed_object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3a7241818c4291dd93250584f8d2952 inherit pro_methods_classhazelcast_1_1client_1_1_distributed_object"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhazelcast_1_1client_1_1_distributed_object.html#ac3a7241818c4291dd93250584f8d2952">listen</a> (const impl::PortableRequest *registrationRequest, int partitionId, impl::BaseEventHandler *handler)</td></tr>
<tr class="memdesc:ac3a7241818c4291dd93250584f8d2952 inherit pro_methods_classhazelcast_1_1client_1_1_distributed_object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal API.  <a href="#ac3a7241818c4291dd93250584f8d2952">More...</a><br/></td></tr>
<tr class="separator:ac3a7241818c4291dd93250584f8d2952 inherit pro_methods_classhazelcast_1_1client_1_1_distributed_object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b5b938cbc44bb712555474dd350c21e inherit pro_methods_classhazelcast_1_1client_1_1_distributed_object"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhazelcast_1_1client_1_1_distributed_object.html#a2b5b938cbc44bb712555474dd350c21e">listen</a> (const impl::PortableRequest *registrationRequest, impl::BaseEventHandler *handler)</td></tr>
<tr class="memdesc:a2b5b938cbc44bb712555474dd350c21e inherit pro_methods_classhazelcast_1_1client_1_1_distributed_object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal API.  <a href="#a2b5b938cbc44bb712555474dd350c21e">More...</a><br/></td></tr>
<tr class="separator:a2b5b938cbc44bb712555474dd350c21e inherit pro_methods_classhazelcast_1_1client_1_1_distributed_object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7842fa1472d63193822acfb9ab4a1b34 inherit pro_methods_classhazelcast_1_1client_1_1_distributed_object"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhazelcast_1_1client_1_1_distributed_object.html#a7842fa1472d63193822acfb9ab4a1b34">stopListening</a> (impl::BaseRemoveListenerRequest *request, const std::string &amp;registrationId)</td></tr>
<tr class="memdesc:a7842fa1472d63193822acfb9ab4a1b34 inherit pro_methods_classhazelcast_1_1client_1_1_distributed_object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal API.  <a href="#a7842fa1472d63193822acfb9ab4a1b34">More...</a><br/></td></tr>
<tr class="separator:a7842fa1472d63193822acfb9ab4a1b34 inherit pro_methods_classhazelcast_1_1client_1_1_distributed_object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8efd57d3aeb21387878dd90436d7f499 inherit pro_methods_classhazelcast_1_1client_1_1_distributed_object"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhazelcast_1_1client_1_1_distributed_object.html#a8efd57d3aeb21387878dd90436d7f499">getPartitionId</a> (const serialization::pimpl::Data &amp;key)</td></tr>
<tr class="memdesc:a8efd57d3aeb21387878dd90436d7f499 inherit pro_methods_classhazelcast_1_1client_1_1_distributed_object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal API.  <a href="#a8efd57d3aeb21387878dd90436d7f499">More...</a><br/></td></tr>
<tr class="separator:a8efd57d3aeb21387878dd90436d7f499 inherit pro_methods_classhazelcast_1_1client_1_1_distributed_object"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename K, typename V&gt;<br/>
class hazelcast::client::IMap&lt; K, V &gt;</h3>

<p>Concurrent, distributed, observable and queryable map client. </p>
<p>Notice that this class have a private constructor. You can access get an <a class="el" href="classhazelcast_1_1client_1_1_i_map.html" title="Concurrent, distributed, observable and queryable map client. ">IMap</a> in the following way </p>
<pre class="fragment"> ClientConfig clientConfig;
 HazelcastClient client(clientConfig);
 IMap&lt;int,std::string&gt; imap = client.getMap&lt;int,std::string&gt;("aKey");
</pre><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">&lt;K&gt;</td><td>key </td></tr>
    <tr><td class="paramname">&lt;V&gt;</td><td>value </td></tr>
  </table>
  </dd>
</dl>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a762e0fc1866d40540391e0b18104e37b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K , typename V &gt; </div>
<div class="memtemplate">
template&lt;typename L &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="classhazelcast_1_1client_1_1_i_map.html">hazelcast::client::IMap</a>&lt; K, V &gt;::addEntryListener </td>
          <td>(</td>
          <td class="paramtype">L &amp;&#160;</td>
          <td class="paramname"><em>listener</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>includeValue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds an entry listener for this map. </p>
<p>Listener will get notified for all map add/remove/update/evict events.</p>
<p>Listener class should be like in the following example. </p>
<pre class="fragment"> class MyListener {
 public:
     //....

    void entryAdded(EntryEvent&lt;string, string&gt; &amp;event) {
         //....
     };

     void entryRemoved(EntryEvent&lt;string, string&gt; &amp;event) {
         //....
     }

     void entryUpdated(EntryEvent&lt;string, string&gt; &amp;event) {
         //....
     }

     void entryEvicted(EntryEvent&lt;string, string&gt; &amp;event) {
         //....
     }
 }
</pre><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">listener</td><td>entry listener </td></tr>
    <tr><td class="paramname">includeValue</td><td><code>true</code> if <code><a class="el" href="classhazelcast_1_1client_1_1_entry_event.html" title="Map Entry event. ">EntryEvent</a></code> should contain the value. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a337fc469db87ddde7c5abe1cb32b9a0c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K , typename V &gt; </div>
<div class="memtemplate">
template&lt;typename L &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="classhazelcast_1_1client_1_1_i_map.html">hazelcast::client::IMap</a>&lt; K, V &gt;::addEntryListener </td>
          <td>(</td>
          <td class="paramtype">L &amp;&#160;</td>
          <td class="paramname"><em>listener</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const K &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>includeValue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds the specified entry listener for the specified key. </p>
<p>The listener will get notified for all add/remove/update/evict events of the specified key only.</p>
<p>Listener class should be like in the following example. </p>
<pre class="fragment"> class MyListener {
 public:
     //....

    void entryAdded(EntryEvent&lt;string, string&gt; &amp;event) {
         //....
     };

     void entryRemoved(EntryEvent&lt;string, string&gt; &amp;event) {
         //....
     }

     void entryUpdated(EntryEvent&lt;string, string&gt; &amp;event) {
         //....
     }

     void entryEvicted(EntryEvent&lt;string, string&gt; &amp;event) {
         //....
     }
 }
</pre><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">listener</td><td>entry listener </td></tr>
    <tr><td class="paramname">key</td><td>key to listen </td></tr>
    <tr><td class="paramname">includeValue</td><td><code>true</code> if <code><a class="el" href="classhazelcast_1_1client_1_1_entry_event.html" title="Map Entry event. ">EntryEvent</a></code> should contain the value. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a8cdcb167ddbbbbf3d2339e488804f0c0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K , typename V &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classhazelcast_1_1client_1_1_i_map.html">hazelcast::client::IMap</a>&lt; K, V &gt;::addIndex </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>attribute</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>ordered</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds an index to this map for the specified entries so that queries can run faster. </p>
<p>Let's say your map values are Employee objects.</p>
<p>class Employee : public <a class="el" href="classhazelcast_1_1client_1_1serialization_1_1_portable.html" title="Classes that will be used with hazelcast data structures like IMap, IQueue etc. ">serialization::Portable</a> { //... private: bool active; int age; std::string name;</p>
<p>}</p>
<p>If you are querying your values mostly based on age and active then you should consider indexing these fields.</p>
<p>IMap&lt;std::string, Employee &gt; imap = hazelcastInstance.getMap&lt;std::string, Employee &gt;("employees"); imap.addIndex("age", true); // ordered, since we have ranged queries for this field imap.addIndex("active", false); // not ordered, because boolean field cannot have range</p>
<p>In the server side, Index should either have a getter method or be public. You should also make sure to add the indexes before adding entries to this map.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">attribute</td><td>attribute of value </td></tr>
    <tr><td class="paramname">ordered</td><td><code>true</code> if index should be ordered, <code>false</code> otherwise. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae615c0210313b3adf012adb5c660d869"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K , typename V &gt; </div>
<div class="memtemplate">
template&lt;typename MapInterceptor &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="classhazelcast_1_1client_1_1_i_map.html">hazelcast::client::IMap</a>&lt; K, V &gt;::addInterceptor </td>
          <td>(</td>
          <td class="paramtype">MapInterceptor &amp;&#160;</td>
          <td class="paramname"><em>interceptor</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds an interceptor for this map. </p>
<p>Added interceptor will intercept operations and execute user defined methods and will cancel operations if user defined method throw exception.</p>
<p>Interceptor should extend either Portable or IdentifiedSerializable. Notice that map interceptor runs on the nodes. Because of that same class should be implemented in java side with same classId and factoryId. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">interceptor</td><td>map interceptor </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>id of registered interceptor </dd></dl>

</div>
</div>
<a class="anchor" id="ac7f66084e434121130a1d465ba5ade05"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K , typename V &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classhazelcast_1_1client_1_1_i_map.html">hazelcast::client::IMap</a>&lt; K, V &gt;::clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes all of the mappings from this map (optional operation). </p>
<p>The map will be empty after this call returns. </p>

</div>
</div>
<a class="anchor" id="a170cef2114ceabeaa01b1092c82cc046"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K , typename V &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classhazelcast_1_1client_1_1_i_map.html">hazelcast::client::IMap</a>&lt; K, V &gt;::containsKey </td>
          <td>(</td>
          <td class="paramtype">const K &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>check if this map contains key. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if contains, false otherwise </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">IClassCastException</td><td>if the type of the specified element is incompatible with the server side. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ace9b22183aa574e350b58b6f36836156"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K , typename V &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classhazelcast_1_1client_1_1_i_map.html">hazelcast::client::IMap</a>&lt; K, V &gt;::containsValue </td>
          <td>(</td>
          <td class="paramtype">const V &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>check if this map contains value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if contains, false otherwise </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">IClassCastException</td><td>if the type of the specified element is incompatible with the server side. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a2e60c0902de0a8cfb92affdd1881df8d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K , typename V &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classhazelcast_1_1client_1_1_i_map.html">hazelcast::client::IMap</a>&lt; K, V &gt;::deleteEntry </td>
          <td>(</td>
          <td class="paramtype">const K &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>removes entry from map. </p>
<p>Does not return anything. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>The key of the map entry to remove. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">IClassCastException</td><td>if the type of the specified element is incompatible with the server side. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a77529aa3ed118517d59357362f4a049c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K , typename V &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::pair&lt;K, V&gt; &gt; <a class="el" href="classhazelcast_1_1client_1_1_i_map.html">hazelcast::client::IMap</a>&lt; K, V &gt;::entrySet </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a std::vector&lt; std::pair&lt;K, V&gt; &gt; clone of the mappings contained in this map. </p>
<p>The vector is <b>NOT</b> backed by the map, so changes to the map are <b>NOT</b> reflected in the set, and vice-versa.</p>
<dl class="section return"><dt>Returns</dt><dd>a vector clone of the keys mappings in this map </dd></dl>

</div>
</div>
<a class="anchor" id="a296ae915e85d7376c4629ab1e4686662"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K , typename V &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::pair&lt;K, V&gt; &gt; <a class="el" href="classhazelcast_1_1client_1_1_i_map.html">hazelcast::client::IMap</a>&lt; K, V &gt;::entrySet </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>sql</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Queries the map based on the specified sql predicate and returns the matching entries. </p>
<p>Specified predicate runs on all members in parallel.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sql</td><td>string query criteria </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>result entry vector of the query </dd></dl>

</div>
</div>
<a class="anchor" id="a998d5cb825215da4452dcfba68a44693"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K , typename V &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classhazelcast_1_1client_1_1_i_map.html">hazelcast::client::IMap</a>&lt; K, V &gt;::evict </td>
          <td>(</td>
          <td class="paramtype">const K &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Evicts the specified key from this map. </p>
<p>If a <code>MapStore</code> defined for this map, then the entry is not deleted from the underlying <code>MapStore</code>, evict only removes the entry from the memory.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>key to evict </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the key is evicted, <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="ad1825dd18743a360e3dbf5b491b65808"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K , typename V &gt; </div>
<div class="memtemplate">
template&lt;typename ResultType , typename EntryProcessor &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::map&lt;K, ResultType&gt; <a class="el" href="classhazelcast_1_1client_1_1_i_map.html">hazelcast::client::IMap</a>&lt; K, V &gt;::executeOnEntries </td>
          <td>(</td>
          <td class="paramtype">EntryProcessor &amp;&#160;</td>
          <td class="paramname"><em>entryProcessor</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Applies the user defined EntryProcessor to the entry mapped by the key with specified ExecutionCallback to listen event status and returns immediately. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>key to be processed </td></tr>
    <tr><td class="paramname">entryProcessor</td><td>processor to process the key </td></tr>
    <tr><td class="paramname">callback</td><td>to listen whether operation is finished or not Applies the user defined EntryProcessor to the entry mapped by the key. Returns immediately with a Future representing that task.</td></tr>
    <tr><td class="paramname">key</td><td>key to be processed </td></tr>
    <tr><td class="paramname">entryProcessor</td><td>processor to process the key </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Future from which the result of the operation can be retrieved. </dd></dl>
<dl class="section see"><dt>See Also</dt><dd>java.util.concurrent.Future Applies the user defined EntryProcessor to the all entries in the map. Returns the results mapped by each key in the map.</dd></dl>
<p>EntryProcessor should extend either Portable or IdentifiedSerializable. Notice that map EntryProcessor runs on the nodes. Because of that, same class should be implemented in java side with same classId and factoryId. </p>

</div>
</div>
<a class="anchor" id="a4f9de0e8c5b65dbc96410125a5167f15"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K , typename V &gt; </div>
<div class="memtemplate">
template&lt;typename ResultType , typename EntryProcessor &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ResultType <a class="el" href="classhazelcast_1_1client_1_1_i_map.html">hazelcast::client::IMap</a>&lt; K, V &gt;::executeOnKey </td>
          <td>(</td>
          <td class="paramtype">const K &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">EntryProcessor &amp;&#160;</td>
          <td class="paramname"><em>entryProcessor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Applies the user defined EntryProcessor to the entry mapped by the key. </p>
<p>Returns the the ResultType which is result of the process() method of EntryProcessor.</p>
<p>EntryProcessor should extend either Portable or IdentifiedSerializable. Notice that map EntryProcessor runs on the nodes. Because of that, same class should be implemented in java side with same classId and factoryId. </p>
<dl class="section return"><dt>Returns</dt><dd>result of entry process. </dd></dl>

</div>
</div>
<a class="anchor" id="a4dd49115922a7061ba027b992878aa52"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K , typename V &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classhazelcast_1_1client_1_1_i_map.html">hazelcast::client::IMap</a>&lt; K, V &gt;::forceUnlock </td>
          <td>(</td>
          <td class="paramtype">const K &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Releases the lock for the specified key regardless of the lock owner. </p>
<p>It always successfully unlocks the key, never blocks and returns immediately.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>key to lock. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aba1680c329399db804ca1c150332ef39"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K , typename V &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">boost::shared_ptr&lt;V&gt; <a class="el" href="classhazelcast_1_1client_1_1_i_map.html">hazelcast::client::IMap</a>&lt; K, V &gt;::get </td>
          <td>(</td>
          <td class="paramtype">const K &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>get the value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>value value in shared_ptr, if there is no mapping for key then return NULL in shared_ptr. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">IClassCastException</td><td>if the type of the specified element is incompatible with the server side. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a7209df2551c29105c6d261f720d1c491"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K , typename V &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::map&lt; K, V &gt; <a class="el" href="classhazelcast_1_1client_1_1_i_map.html">hazelcast::client::IMap</a>&lt; K, V &gt;::getAll </td>
          <td>(</td>
          <td class="paramtype">const std::set&lt; K &gt; &amp;&#160;</td>
          <td class="paramname"><em>keys</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the entries for the given keys. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">keys</td><td>keys to get </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>map of entries </dd></dl>

</div>
</div>
<a class="anchor" id="a9f2b7d543db528e24e90848e60129f6d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K , typename V &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhazelcast_1_1client_1_1_entry_view.html">EntryView</a>&lt;K, V&gt; <a class="el" href="classhazelcast_1_1client_1_1_i_map.html">hazelcast::client::IMap</a>&lt; K, V &gt;::getEntryView </td>
          <td>(</td>
          <td class="paramtype">const K &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds an continuous entry listener for this map. </p>
<p>Listener will get notified for map add/remove/update/evict events filtered by given predicate.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">listener</td><td>entry listener </td></tr>
    <tr><td class="paramname">predicate</td><td>predicate for filtering entries </td></tr>
    <tr><td class="paramname">includeValue</td><td><code>true</code> if <code><a class="el" href="classhazelcast_1_1client_1_1_entry_event.html" title="Map Entry event. ">EntryEvent</a></code> should contain the value. Adds an continuous entry listener for this map. Listener will get notified for map add/remove/update/evict events filtered by given predicate.</td></tr>
    <tr><td class="paramname">listener</td><td>entry listener </td></tr>
    <tr><td class="paramname">predicate</td><td>predicate for filtering entries </td></tr>
    <tr><td class="paramname">key</td><td>key to listen </td></tr>
    <tr><td class="paramname">includeValue</td><td><code>true</code> if <code><a class="el" href="classhazelcast_1_1client_1_1_entry_event.html" title="Map Entry event. ">EntryEvent</a></code> should contain the value. Returns the <code><a class="el" href="classhazelcast_1_1client_1_1_entry_view.html" title="EntryView represents a readonly view of a map entry. ">EntryView</a></code> for the specified key.</td></tr>
    <tr><td class="paramname">key</td><td>key of the entry </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code><a class="el" href="classhazelcast_1_1client_1_1_entry_view.html" title="EntryView represents a readonly view of a map entry. ">EntryView</a></code> of the specified key </dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="classhazelcast_1_1client_1_1_entry_view.html" title="EntryView represents a readonly view of a map entry. ">EntryView</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a2fe482267adc581fbf06c19395e24b5d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K , typename V &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classhazelcast_1_1client_1_1_i_map.html">hazelcast::client::IMap</a>&lt; K, V &gt;::isEmpty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns <code>true</code> if this map contains no key-value mappings. </p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if this map contains no key-value mappings </dd></dl>

</div>
</div>
<a class="anchor" id="abf89902b2b1cd6a697d3d83de4d2f591"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K , typename V &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classhazelcast_1_1client_1_1_i_map.html">hazelcast::client::IMap</a>&lt; K, V &gt;::isLocked </td>
          <td>(</td>
          <td class="paramtype">const K &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks the lock for the specified key. </p>
<p>If the lock is acquired then returns true, else false.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>key to lock to be checked. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if lock is acquired, <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a705cb50f8bb69cb1e4a41b0ae295b185"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K , typename V &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;K&gt; <a class="el" href="classhazelcast_1_1client_1_1_i_map.html">hazelcast::client::IMap</a>&lt; K, V &gt;::keySet </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a vector clone of the keys contained in this map. </p>
<p>The vector is <b>NOT</b> backed by the map, so changes to the map are <b>NOT</b> reflected in the vector, and vice-versa.</p>
<dl class="section return"><dt>Returns</dt><dd>a vector clone of the keys contained in this map </dd></dl>

</div>
</div>
<a class="anchor" id="a9b2e5e447b66b769d7a4786783bc5719"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K , typename V &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;K&gt; <a class="el" href="classhazelcast_1_1client_1_1_i_map.html">hazelcast::client::IMap</a>&lt; K, V &gt;::keySet </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>sql</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Queries the map based on the specified sql predicate and returns the keys of matching entries. </p>
<p>Specified predicate runs on all members in parallel.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sql</td><td>string query criteria </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>result key set of the query </dd></dl>

</div>
</div>
<a class="anchor" id="a3fd16e702dcecd6275b77d215a799ef6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K , typename V &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classhazelcast_1_1client_1_1_i_map.html">hazelcast::client::IMap</a>&lt; K, V &gt;::lock </td>
          <td>(</td>
          <td class="paramtype">const K &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Acquires the lock for the specified key. </p>
<p>If the lock is not available then the current thread becomes disabled for thread scheduling purposes and lies dormant until the lock has been acquired.</p>
<p>Scope of the lock is this map only. Acquired lock is only for the key in this map.</p>
<p>Locks are re-entrant so if the key is locked N times then it should be unlocked N times before another thread can acquire it.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>key to lock. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a669e64771b5fe1e8c50421708182d68a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K , typename V &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classhazelcast_1_1client_1_1_i_map.html">hazelcast::client::IMap</a>&lt; K, V &gt;::lock </td>
          <td>(</td>
          <td class="paramtype">const K &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>leaseTime</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Acquires the lock for the specified key for the specified lease time. </p>
<p>After lease time, lock will be released..</p>
<p>If the lock is not available then the current thread becomes disabled for thread scheduling purposes and lies dormant until the lock has been acquired.</p>
<p>Scope of the lock is this map only. Acquired lock is only for the key in this map.</p>
<p>Locks are re-entrant so if the key is locked N times then it should be unlocked N times before another thread can acquire it.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>key to lock. </td></tr>
    <tr><td class="paramname">leaseTime</td><td>time in milliseconds to wait before releasing the lock. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a8cb0ccd484b05987e51cbe4279feeacc"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K , typename V &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">boost::shared_ptr&lt;V&gt; <a class="el" href="classhazelcast_1_1client_1_1_i_map.html">hazelcast::client::IMap</a>&lt; K, V &gt;::put </td>
          <td>(</td>
          <td class="paramtype">const K &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const V &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>put new entry into map. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td></td></tr>
    <tr><td class="paramname">value</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the previous value in shared_ptr, if there is no mapping for key </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">IClassCastException</td><td>if the type of the specified elements are incompatible with the server side. then returns NULL in shared_ptr. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a8860b7349d09e9a890ae0ed856863736"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K , typename V &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">boost::shared_ptr&lt;V&gt; <a class="el" href="classhazelcast_1_1client_1_1_i_map.html">hazelcast::client::IMap</a>&lt; K, V &gt;::put </td>
          <td>(</td>
          <td class="paramtype">const K &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const V &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>ttlInMillis</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Puts an entry into this map with a given ttl (time to live) value. </p>
<p>Entry will expire and get evicted after the ttl. If ttl is 0, then the entry lives forever.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>key of the entry </td></tr>
    <tr><td class="paramname">value</td><td>value of the entry </td></tr>
    <tr><td class="paramname">ttl</td><td>maximum time for this entry to stay in the map in milliseconds, 0 means infinite. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the previous value in shared_ptr, if there is no mapping for key then returns NULL in shared_ptr. </dd></dl>

</div>
</div>
<a class="anchor" id="ac2470be3eba624eaee105fe121f24378"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K , typename V &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classhazelcast_1_1client_1_1_i_map.html">hazelcast::client::IMap</a>&lt; K, V &gt;::putAll </td>
          <td>(</td>
          <td class="paramtype">const std::map&lt; K, V &gt; &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies all of the mappings from the specified map to this map (optional operation). </p>
<p>The effect of this call is equivalent to that of calling #put(Object,Object) put(k, v) on this map once for each mapping from key <code>k</code> to value <code>v</code> in the specified map. The behavior of this operation is undefined if the specified map is modified while the operation is in progress.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>mappings to be stored in this map </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a15ce0a97c73b5f3af6fd83beec865990"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K , typename V &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">boost::shared_ptr&lt;V&gt; <a class="el" href="classhazelcast_1_1client_1_1_i_map.html">hazelcast::client::IMap</a>&lt; K, V &gt;::putIfAbsent </td>
          <td>(</td>
          <td class="paramtype">const K &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const V &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Puts an entry into this map, if the specified key is not already associated with a value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>key with which the specified value is to be associated </td></tr>
    <tr><td class="paramname">value</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the previous value in shared_ptr, if there is no mapping for key then returns NULL in shared_ptr. </dd></dl>

</div>
</div>
<a class="anchor" id="aea8f5740ecb60d3c644966f29e79f9b3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K , typename V &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">boost::shared_ptr&lt;V&gt; <a class="el" href="classhazelcast_1_1client_1_1_i_map.html">hazelcast::client::IMap</a>&lt; K, V &gt;::putIfAbsent </td>
          <td>(</td>
          <td class="paramtype">const K &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const V &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>ttlInMillis</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Puts an entry into this map with a given ttl (time to live) value if the specified key is not already associated with a value. </p>
<p>Entry will expire and get evicted after the ttl.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>key of the entry </td></tr>
    <tr><td class="paramname">value</td><td>value of the entry </td></tr>
    <tr><td class="paramname">ttl</td><td>maximum time in milliseconds for this entry to stay in the map </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the previous value of the entry, if there is no mapping for key then returns NULL in shared_ptr. </dd></dl>

</div>
</div>
<a class="anchor" id="a28a84b2c9f14d55b40b26d28dd829bcd"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K , typename V &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classhazelcast_1_1client_1_1_i_map.html">hazelcast::client::IMap</a>&lt; K, V &gt;::putTransient </td>
          <td>(</td>
          <td class="paramtype">const K &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const V &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>ttlInMillis</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Same as put(K, V, long, TimeUnit) but MapStore, if defined, will not be called to store/persist the entry. </p>
<p>If ttl is 0, then the entry lives forever.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>key of the entry </td></tr>
    <tr><td class="paramname">value</td><td>value of the entry </td></tr>
    <tr><td class="paramname">ttl</td><td>maximum time for this entry to stay in the map in milliseconds, 0 means infinite. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a43dff4b730688415ef98e6496af2131d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K , typename V &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">boost::shared_ptr&lt;V&gt; <a class="el" href="classhazelcast_1_1client_1_1_i_map.html">hazelcast::client::IMap</a>&lt; K, V &gt;::remove </td>
          <td>(</td>
          <td class="paramtype">const K &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>remove entry form map </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the previous value in shared_ptr, if there is no mapping for key then returns NULL in shared_ptr. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">IClassCastException</td><td>if the type of the specified element is incompatible with the server side. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab64154342e35f53d72c4401e920b085a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K , typename V &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classhazelcast_1_1client_1_1_i_map.html">hazelcast::client::IMap</a>&lt; K, V &gt;::remove </td>
          <td>(</td>
          <td class="paramtype">const K &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const V &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>removes entry from map if there is an entry with same key and value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td></td></tr>
    <tr><td class="paramname">value</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if remove is successful false otherwise </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">IClassCastException</td><td>if the type of the specified element is incompatible with the server side. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a7f632026d7cf4069ddb6ab8212a7e532"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K , typename V &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classhazelcast_1_1client_1_1_i_map.html">hazelcast::client::IMap</a>&lt; K, V &gt;::removeEntryListener </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>registrationId</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes the specified entry listener Returns silently if there is no such listener added before. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>id of registered listener</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if registration is removed, false otherwise </dd></dl>

</div>
</div>
<a class="anchor" id="a7a4b134bc0a6938d07ba3066b9db3cab"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K , typename V &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classhazelcast_1_1client_1_1_i_map.html">hazelcast::client::IMap</a>&lt; K, V &gt;::removeInterceptor </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes the given interceptor for this map. </p>
<p>So it will not intercept operations anymore.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>registration id of map interceptor </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a027c6346d0cbdfbea6800e12f5c1e02c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K , typename V &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classhazelcast_1_1client_1_1_i_map.html">hazelcast::client::IMap</a>&lt; K, V &gt;::replace </td>
          <td>(</td>
          <td class="paramtype">const K &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const V &amp;&#160;</td>
          <td class="paramname"><em>oldValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const V &amp;&#160;</td>
          <td class="paramname"><em>newValue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Replaces the entry for a key only if currently mapped to a given value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>key with which the specified value is associated </td></tr>
    <tr><td class="paramname">oldValue</td><td>value expected to be associated with the specified key </td></tr>
    <tr><td class="paramname">newValue</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the value was replaced </dd></dl>

</div>
</div>
<a class="anchor" id="ad590b52ee71f28f454d0b562d518f795"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K , typename V &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">boost::shared_ptr&lt;V&gt; <a class="el" href="classhazelcast_1_1client_1_1_i_map.html">hazelcast::client::IMap</a>&lt; K, V &gt;::replace </td>
          <td>(</td>
          <td class="paramtype">const K &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const V &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Replaces the entry for a key only if currently mapped to some value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>key with which the specified value is associated </td></tr>
    <tr><td class="paramname">value</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the previous value of the entry, if there is no mapping for key then returns NULL in shared_ptr. </dd></dl>

</div>
</div>
<a class="anchor" id="a7661edfc60b8ae71ca420a25af350c2b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K , typename V &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classhazelcast_1_1client_1_1_i_map.html">hazelcast::client::IMap</a>&lt; K, V &gt;::set </td>
          <td>(</td>
          <td class="paramtype">const K &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const V &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>ttl</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Puts an entry into this map. </p>
<p>Similar to put operation except that set doesn't return the old value which is more efficient. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>key with which the specified value is associated </td></tr>
    <tr><td class="paramname">value</td><td></td></tr>
    <tr><td class="paramname">ttl</td><td>maximum time in milliseconds for this entry to stay in the map 0 means infinite. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a809bccb891ae0086fde856051ec4637d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K , typename V &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classhazelcast_1_1client_1_1_i_map.html">hazelcast::client::IMap</a>&lt; K, V &gt;::set </td>
          <td>(</td>
          <td class="paramtype">const K &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const V &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Applies the user defined EntryProcessor to the entries in the map which satisfies provided predicate. </p>
<p>Returns the results mapped by each key in the map. Applies the user defined EntryProcessor to the entries mapped by the collection of keys. the results mapped by each key in the collection.</p>
<dl class="section return"><dt>Returns</dt><dd>result of entry process. Puts an entry into this map. Similar to put operation except that set doesn't return the old value which is more efficient. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td></td></tr>
    <tr><td class="paramname">value</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a60b5bf7ac909ca4df929bb629ecd7ea4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K , typename V &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classhazelcast_1_1client_1_1_i_map.html">hazelcast::client::IMap</a>&lt; K, V &gt;::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of key-value mappings in this map. </p>
<p>If the map contains more than <code>Integer.MAX_VALUE</code> elements, returns <code>Integer.MAX_VALUE</code>.</p>
<dl class="section return"><dt>Returns</dt><dd>the number of key-value mappings in this map </dd></dl>

</div>
</div>
<a class="anchor" id="a264f894e0ab8ee3af07c963e366f3334"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K , typename V &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classhazelcast_1_1client_1_1_i_map.html">hazelcast::client::IMap</a>&lt; K, V &gt;::tryLock </td>
          <td>(</td>
          <td class="paramtype">const K &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Tries to acquire the lock for the specified key. </p>
<p>If the lock is not available then the current thread doesn't wait and returns false immediately.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>key to lock. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if lock is acquired, <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="accfd6a35fd9fdb6d0f19385b0998cfa9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K , typename V &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classhazelcast_1_1client_1_1_i_map.html">hazelcast::client::IMap</a>&lt; K, V &gt;::tryLock </td>
          <td>(</td>
          <td class="paramtype">const K &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>timeInMillis</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Tries to acquire the lock for the specified key. </p>
<p>If the lock is not available then the current thread becomes disabled for thread scheduling purposes and lies dormant until one of two things happens: </p>
<ul>
<li>
The lock is acquired by the current thread; or </li>
<li>
The specified waiting time elapses </li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>key to lock in this map </td></tr>
    <tr><td class="paramname">time</td><td>maximum time in milliseconds to wait for the lock </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the lock was acquired and <code>false</code> if the waiting time elapsed before the lock was acquired. </dd></dl>

</div>
</div>
<a class="anchor" id="afb32c9b7337c472b6e9093a5545c70dd"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K , typename V &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classhazelcast_1_1client_1_1_i_map.html">hazelcast::client::IMap</a>&lt; K, V &gt;::tryPut </td>
          <td>(</td>
          <td class="paramtype">const K &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const V &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>timeoutInMillis</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Tries to put the given key, value into this map within specified timeout value. </p>
<p>If this method returns false, it means that the caller thread couldn't acquire the lock for the key within timeout duration, thus put operation is not successful.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>key of the entry </td></tr>
    <tr><td class="paramname">value</td><td>value of the entry </td></tr>
    <tr><td class="paramname">timeout</td><td>maximum time to wait in milliseconds </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the put is successful, <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="aafa1adff6d21dcf64ddae18b4edd01b0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K , typename V &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classhazelcast_1_1client_1_1_i_map.html">hazelcast::client::IMap</a>&lt; K, V &gt;::tryRemove </td>
          <td>(</td>
          <td class="paramtype">const K &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>timeoutInMillis</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Asynchronously gets the given key. </p>
<p><code> Future future = map.getAsync(key); // do some other stuff, when ready get the result Object value = future.get(); </code> Future.get() will block until the actual map.get() completes. If the application requires timely response, then Future.get(timeout, timeunit) can be used. <code> try{ Future future = map.getAsync(key); Object value = future.get(40, TimeUnit.MILLISECOND); }catch (TimeoutException t) { // time wasn't enough } </code> ExecutionException is never thrown.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>the key of the map entry </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Future from which the value of the key can be retrieved.</dd></dl>
<dl class="section see"><dt>See Also</dt><dd>java.util.concurrent.Future </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">IClassCastException</td><td>if the type of the specified element is incompatible with the server side. Asynchronously puts the given key and value. <code> Future future = map.putAsync(key, value); // do some other stuff, when ready get the result Object oldValue = future.get(); </code> Future.get() will block until the actual map.get() completes. If the application requires timely response, then Future.get(timeout, timeunit) can be used. <code> try{ Future future = map.putAsync(key, newValue); Object oldValue = future.get(40, TimeUnit.MILLISECOND); }catch (TimeoutException t) { // time wasn't enough } </code> ExecutionException is never thrown.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>the key of the map entry </td></tr>
    <tr><td class="paramname">value</td><td>the new value of the map entry </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Future from which the old value of the key can be retrieved. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">NullPointerException</td><td>if the specified key or value is null </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See Also</dt><dd>java.util.concurrent.Future </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">IClassCastException</td><td>if the type of the specified element is incompatible with the server side. Asynchronously puts the given key and value into this map with a given ttl (time to live) value. Entry will expire and get evicted after the ttl. If ttl is 0, then the entry lives forever. <code> Future future = map.putAsync(key, value, ttl, timeunit); // do some other stuff, when ready get the result Object oldValue = future.get(); </code> Future.get() will block until the actual map.get() completes. If the application requires timely response, then Future.get(timeout, timeunit) can be used. <code> try{ Future future = map.putAsync(key, newValue, ttl, timeunit); Object oldValue = future.get(40, TimeUnit.MILLISECOND); }catch (TimeoutException t) { // time wasn't enough } </code> ExecutionException is never thrown.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>the key of the map entry </td></tr>
    <tr><td class="paramname">value</td><td>the new value of the map entry </td></tr>
    <tr><td class="paramname">ttl</td><td>maximum time for this entry to stay in the map 0 means infinite. </td></tr>
    <tr><td class="paramname">timeunit</td><td>time unit for the ttl </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Future from which the old value of the key can be retrieved. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">NullPointerException</td><td>if the specified key or value is null </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See Also</dt><dd>java.util.concurrent.Future Asynchronously removes the given key.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>The key of the map entry to remove. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A java.util.concurrent.Future from which the value removed from the map can be retrieved. Tries to remove the entry with the given key from this map within specified timeout value. If the key is already locked by another thread and/or member, then this operation will wait timeout amount for acquiring the lock. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>key of the entry </td></tr>
    <tr><td class="paramname">timeout</td><td>maximum time in milliseconds to wait for acquiring the lock for the key </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac7a129c364501f111fadc943989049c2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K , typename V &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classhazelcast_1_1client_1_1_i_map.html">hazelcast::client::IMap</a>&lt; K, V &gt;::unlock </td>
          <td>(</td>
          <td class="paramtype">const K &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Releases the lock for the specified key. </p>
<p>It never blocks and returns immediately.</p>
<p>If the current thread is the holder of this lock then the hold count is decremented. If the hold count is now zero then the lock is released. If the current thread is not the holder of this lock then IllegalMonitorStateException is thrown.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>key to lock. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">IllegalMonitorStateException</td><td>if the current thread does not hold this lock MTODO </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a3e8c93cd26956bb02f280cabb41d4c65"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K , typename V &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;V&gt; <a class="el" href="classhazelcast_1_1client_1_1_i_map.html">hazelcast::client::IMap</a>&lt; K, V &gt;::values </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a vector clone of the values contained in this map. </p>
<p>The vector is <b>NOT</b> backed by the map, so changes to the map are <b>NOT</b> reflected in the collection, and vice-versa.</p>
<dl class="section return"><dt>Returns</dt><dd>a vector clone of the values contained in this map </dd></dl>

</div>
</div>
<a class="anchor" id="ad5cd74d9d42d8c4f03c1ba3501c3043d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K , typename V &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;V&gt; <a class="el" href="classhazelcast_1_1client_1_1_i_map.html">hazelcast::client::IMap</a>&lt; K, V &gt;::values </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>sql</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Queries the map based on the specified predicate and returns the values of matching entries. </p>
<p>Specified predicate runs on all members in parallel.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">predicate</td><td>query criteria </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>result value vector of the query </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>hazelcast/include/hazelcast/client/<a class="el" href="_i_map_8h_source.html">IMap.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Thu May 15 2014 16:20:22 for Hazelcast C++ Client by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.5
</small></address>
</body>
</html>
