<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.5"/>
<title>Hazelcast C++ Client: Introduction</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Hazelcast C++ Client
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.5 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li class="current"><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Introduction </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>You can use native C++ Client to connect to hazelcast nodes and make almost all operations that a node does. Different from nodes, clients do not hold data.</p>
<p>Some of features of C++ Clients are:</p>
<ul>
<li>Access to distributed data structures like <a class="el" href="classhazelcast_1_1client_1_1_i_map.html" title="Concurrent, distributed, observable and queryable map client. ">IMap</a>, <a class="el" href="classhazelcast_1_1client_1_1_i_queue.html" title="Concurrent, blocking, distributed, observable, client queue. ">IQueue</a>, <a class="el" href="classhazelcast_1_1client_1_1_multi_map.html" title="A specialized distributed map client whose keys can be associated with multiple values. ">MultiMap</a>, <a class="el" href="classhazelcast_1_1client_1_1_i_topic.html" title="Hazelcast provides distribution mechanism for publishing messages that are delivered to multiple subs...">ITopic</a> etc... <dl class="section see"><dt>See Also</dt><dd><a class="el" href="classhazelcast_1_1client_1_1_distributed_object.html" title="Base class for all distributed objects. ">DistributedObject</a></dd></dl>
</li>
<li>Access to transactional distributed data structures like <a class="el" href="classhazelcast_1_1client_1_1_transactional_map.html" title="Transactional implementation of IMap. ">TransactionalMap</a>, <a class="el" href="classhazelcast_1_1client_1_1_transactional_queue.html" title="Transactional implementation of IQueue. ">TransactionalQueue</a> etc...</li>
<li>Ability to add cluster listeners to a cluster and entry/item listeners to distributed data structures. <dl class="section see"><dt>See Also</dt><dd><a class="el" href="classhazelcast_1_1client_1_1_membership_listener.html" title="Cluster membership listener. ">MembershipListener</a>, <a class="el" href="classhazelcast_1_1client_1_1_i_map.html#a762e0fc1866d40540391e0b18104e37b" title="Adds an entry listener for this map. ">IMap::addEntryListener</a> , <a class="el" href="classhazelcast_1_1client_1_1_i_queue.html#a7be62768383244e230705ee61a22621a" title="Adds an item listener for this collection. ">IQueue::addItemListener</a> etc .</dd></dl>
</li>
<li>Distributed synchronization mechanisms with <a class="el" href="classhazelcast_1_1client_1_1_i_lock.html" title="Re-entrant Lock, Distributed client implementation of Lock. ">ILock</a> , <a class="el" href="classhazelcast_1_1client_1_1_i_semaphore.html" title="ISemaphore is a backed-up distributed alternative to the java.util.concurrent.Semaphore. ">ISemaphore</a> and <a class="el" href="classhazelcast_1_1client_1_1_i_count_down_latch.html" title="ICountDownLatch is a backed-up distributed alternative to the java.util.concurrent.CountDownLatch java.util.concurrent.CountDownLatch. ">ICountDownLatch</a>.</li>
<li>C++ Client is smart by default, which means that it knows where the data is and asks directly to correct node. Note that you can turn this feature off ( <a class="el" href="classhazelcast_1_1client_1_1_client_config.html#a0b81d0714af4083afeb5840a0170a389" title="If true, client will route the key based operations to owner of the key at the best effort...">ClientConfig::setSmart</a>), if you don't want your clients to connect every node.</li>
</ul>
<p>Features that are planned to implement are:</p>
<ul>
<li>Distributed Executor Service</li>
<li>NearCache to store some of the data in client side to reduce latencies.</li>
<li>Access to replicated Map</li>
<li>SSL <a class="el" href="classhazelcast_1_1client_1_1_socket.html" title="c Sockets wrapper class. ">Socket</a> support</li>
<li>Access to AtomicReference</li>
<li>Condition related methods to <a class="el" href="classhazelcast_1_1client_1_1_i_lock.html" title="Re-entrant Lock, Distributed client implementation of Lock. ">ILock</a>.</li>
</ul>
<h1><a class="anchor" id="how_to_setup"></a>
How to Setup</h1>
<p>Hazelcast C++ client is shipped with 32 &amp; 64 bit, shared and static libraries. Compiled static libraries of dependencies are also available in the release.</p>
<p>Dependencies are zlib and shared_ptr from the boost library.</p>
<p>Downloaded release folder consist of</p>
<ul>
<li>Mac_64/</li>
<li>Windows_32/</li>
<li>Windows_64/</li>
<li>Linux_32/</li>
<li>Linux_64/</li>
<li>docs/ =&gt; html doxygen documentations are here.</li>
</ul>
<p>And each of the folders above contains following</p>
<ul>
<li>examples/<ul>
<li>testApp.exe =&gt; example command line client tool to connect hazelcast servers.</li>
<li>TestApp.cpp =&gt; code of the example command line tool.</li>
</ul>
</li>
<li>hazelcast/<ul>
<li>lib/ =&gt; Contains both shared and static library of hazelcast.</li>
<li>include/ =&gt; Contains headers of client</li>
</ul>
</li>
<li>external/<ul>
<li>lib/ =&gt; Contains compiled static libraries of zlib.</li>
<li>include/ =&gt; Contains headers of dependencies.(zlib and boost::shared_ptr)</li>
</ul>
</li>
</ul>
<h1><a class="anchor" id="guides"></a>
Platform Specific Installation Guides</h1>
<p>C++ client is tested on Linux 32/64, Mac 64 and Windows 32/64 bit machines. For each of the headers above, it is assumed that you are in correct folder for your platform. Folders are Mac_64, Windows_32, Windows_64, Linux_32 or Linux_64.</p>
<h2><a class="anchor" id="Linux"></a>
Linux</h2>
<p>For linux, there are two distributions one is 32bit the other is 64bit.</p>
<p>Sample script to build with static library:</p>
<ul>
<li>ï»¿g++ main.cpp -pthread -I./external/include -I./hazelcast/include ./hazelcast/lib/libHazelcastClientStatic_64.a ./external/lib/libz.a</li>
</ul>
<p>Sample script to build with shared library:</p>
<ul>
<li>g++ main.cpp -lpthread -Wl,&ndash;no-as-needed -lrt -I./external/include -I./hazelcast/include -L./hazelcast/lib -lHazelcastClientShared_64 ./external/lib/libz.a</li>
</ul>
<h2><a class="anchor" id="Mac"></a>
Mac</h2>
<p>For Mac, there is only one distribution which is 64 bit.</p>
<p>Sample script to build with static library:</p>
<ul>
<li>g++ main.cpp -I./external/include -I./hazelcast/include ./hazelcast/lib/libHazelcastClientStatic_64.a ./external/lib/darwin/libz.a</li>
</ul>
<p>Sample script to build with shared library:</p>
<ul>
<li>g++ main.cpp -I./external/include -I./hazelcast/include -L./hazelcast/lib -lHazelcastClientShared_64 ./external/lib/darwin/libz.a</li>
</ul>
<h2><a class="anchor" id="Windows"></a>
Windows</h2>
<p>For Windows, there are two distributions one is 32bit the other is 64bit. Currently release have only Visual Studio 2010 compatible libraries. For others please contact with <a href="#" onclick="location.href='mai'+'lto:'+'sup'+'po'+'rt@'+'ha'+'zel'+'ca'+'st.'+'co'+'m'; return false;">suppo<span style="display: none;">.nosp@m.</span>rt@h<span style="display: none;">.nosp@m.</span>azelc<span style="display: none;">.nosp@m.</span>ast.<span style="display: none;">.nosp@m.</span>com</a></p>
<h1><a class="anchor" id="code_samples"></a>
Code Samples</h1>
<p>Note that these codes to work, there should be a Hazelcast node is running.</p>
<h2><a class="anchor" id="map"></a>
Map example</h2>
<pre class="fragment">     #include &lt;hazelcast/client/HazelcastAll.h&gt;
     #include &lt;iostream&gt;

     using namespace hazelcast::client;

     int main(){
         ClientConfig clientConfig;
         Address address("localhost", 5701);
         clientConfig.addAddress(address);

         HazelcastClient hazelcastClient(clientConfig);

         IMap&lt;int,int&gt; myMap = hazelcastClient.getMap&lt;int ,int&gt;("myIntMap");
         myMap.put(1,3);
         boost::shared_ptr&lt;int&gt; v = myMap.get(1);
         if(v.get() != NULL){
             //process the item
         }

         return 0;
     }
</pre><h2><a class="anchor" id="queue"></a>
Queue Example</h2>
<pre class="fragment">     #include &lt;hazelcast/client/HazelcastAll.h&gt;
     #include &lt;iostream&gt;
     #include &lt;string&gt;

     using namespace hazelcast::client;

     int main(){
         ClientConfig clientConfig;
         Address address("localhost", 5701);
         clientConfig.addAddress(address);

         HazelcastClient hazelcastClient(clientConfig);

         IQueue&lt;std::string&gt; q = hazelcastClient.getQueue&lt;std::string&gt;("q");
         q.offer("sample");
         boost::shared_ptr&lt;std::string&gt; v = q.poll();
         if(v.get() != NULL){
             //process the item
         }
         return 0;
     }
</pre><h2><a class="anchor" id="entry_listener"></a>
Entry Listener Example</h2>
<pre class="fragment"> #include "hazelcast/client/ClientConfig.h"
 #include "hazelcast/client/EntryEvent.h"
 #include "hazelcast/client/IMap.h"
 #include "hazelcast/client/Address.h"
 #include "hazelcast/client/HazelcastClient.h"
 #include &lt;iostream&gt;
 #include &lt;string&gt;

 using namespace hazelcast::client;

 class SampleEntryListener {
 public:

     void entryAdded(EntryEvent&lt;std::string, std::string&gt; &amp;event) {
         std::cout &lt;&lt; "entry added " &lt;&lt;  event.getKey() &lt;&lt; " " &lt;&lt; event.getValue() &lt;&lt; std::endl;
     };

     void entryRemoved(EntryEvent&lt;std::string, std::string&gt; &amp;event) {
         std::cout &lt;&lt; "entry added " &lt;&lt;  event.getKey() &lt;&lt; " " &lt;&lt; event.getValue() &lt;&lt; std::endl;
     }

     void entryUpdated(EntryEvent&lt;std::string, std::string&gt; &amp;event) {
         std::cout &lt;&lt; "entry added " &lt;&lt;  event.getKey() &lt;&lt; " " &lt;&lt; event.getValue() &lt;&lt; std::endl;
     }

     void entryEvicted(EntryEvent&lt;std::string, std::string&gt; &amp;event) {
         std::cout &lt;&lt; "entry added " &lt;&lt;  event.getKey() &lt;&lt; " " &lt;&lt; event.getValue() &lt;&lt; std::endl;
     }
 };


 int main(int argc, char **argv) {

     ClientConfig clientConfig;
     Address address("localhost", 5701);
     clientConfig.addAddress(address);

     HazelcastClient hazelcastClient(clientConfig);

     IMap&lt;std::string,std::string&gt; myMap = hazelcastClient.getMap&lt;std::string ,std::string&gt;("myIntMap");
     SampleEntryListener *  listener = new SampleEntryListener();

     std::string id = myMap.addEntryListener(*listener, true);
     myMap.put("key1", "value1"); //prints entryAdded
     myMap.put("key1", "value2"); //prints updated
     myMap.remove("key1"); //prints entryRemoved
     myMap.put("key2", "value2",1000); //prints entryEvicted after 1 second

     myMap.removeEntryListener(id); //WARNING: deleting listener before removing it from hazelcast leads to crashes.
     delete listener;               //delete listener after remove it from hazelcast.
     return 0;
 };
</pre><h2><a class="anchor" id="serialization"></a>
Serialization Example</h2>
<p>Suppose you have the following two classes in Java and you want to use it with C++ client. </p>
<pre class="fragment"> class Foo implements Serializable{
     private int age;
     private String name;
 }

 class Bar implements Serializable{
     private float x;
     private float y;
 }
</pre><p>First make them implement Portable or IdentifiedDataSerializable.</p>
<pre class="fragment"> class Foo implements Portable {
     private int age;
     private String name;

     public int getFactoryId() {
         return 666;   // a positive id that you choose
     }

     public int getClassId() {
         return 2;     // a positive id that you choose
     }

     public void writePortable(PortableWriter writer) throws IOException {
         writer.writeUTF("n", name);
         writer.writeInt("a", age);
     }

     public void readPortable(PortableReader reader) throws IOException {
         name = reader.readUTF("n");
         age = reader.readInt("a");
     }
 }

 class Bar implements IdentifiedDataSerializable {
     private float x;
     private float y;

     public int getFactoryId() {
         return 4;     // a positive id that you choose
     }

     public int getId() {
         return 5;    // a positive id that you choose
     }

     public void writeData(ObjectDataOutput out) throws IOException {
         out.writeFloat(x);
         out.writeFloat(y);
     }

     public void readData(ObjectDataInput in) throws IOException {
         x = in.readFloat();
         y = in.readFloat();
     }
 }
</pre><p>Then, implement the corresponding classes in C++ with same factory and class Id as follows: </p>
<pre class="fragment"> class Foo : public serialization::Portable {
 public:
     int getFactoryId() const{
         return 666;
     };

     int getClassId() const{
         return 2;
     };

     void writePortable(serialization::PortableWriter &amp;writer) const{
         writer.writeUTF("n", name);
         writer.writeInt("a", age);
     };

     void readPortable(serialization::PortableReader &amp;reader){
         name = reader.readUTF("n");
         age = reader.readInt("a");
     };

 private:
     int age;
     std::string name;
 };

 class Bar : public serialization::IdentifiedDataSerializable {
     public:
         int getFactoryId() const{
             return 4;
         };

         int getClassId() const{
             return 2;
         };

         void writeData(serialization::ObjectDataOutput&amp; out) const{
             out.writeFloat(x);
             out.writeFloat(y);
         };

         void readData(serialization::ObjectDataInput&amp; in){
             x = in.readFloat();
             y = in.readFloat();
         };
     private:
         float x;
         float y;
  };
</pre><p>Now, you can use class Foo and Bar in distributed structures. For example as Key or Value of <a class="el" href="classhazelcast_1_1client_1_1_i_map.html" title="Concurrent, distributed, observable and queryable map client. ">IMap</a>, or as an Item in <a class="el" href="classhazelcast_1_1client_1_1_i_queue.html" title="Concurrent, blocking, distributed, observable, client queue. ">IQueue</a></p>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Mon Apr 28 2014 12:21:57 for Hazelcast C++ Client by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.5
</small></address>
</body>
</html>
