<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.5"/>
<title>Hazelcast C++ Client: hazelcast::client::ISemaphore Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Hazelcast C++ Client
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.5 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>hazelcast</b></li><li class="navelem"><b>client</b></li><li class="navelem"><a class="el" href="classhazelcast_1_1client_1_1_i_semaphore.html">ISemaphore</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classhazelcast_1_1client_1_1_i_semaphore-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">hazelcast::client::ISemaphore Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><a class="el" href="classhazelcast_1_1client_1_1_i_semaphore.html" title="ISemaphore is a backed-up distributed alternative to the java.util.concurrent.Semaphore. ">ISemaphore</a> is a backed-up distributed alternative to the java.util.concurrent.Semaphore.  
 <a href="classhazelcast_1_1client_1_1_i_semaphore.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_i_semaphore_8h_source.html">ISemaphore.h</a>&gt;</code></p>
<div id="dynsection-0" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-0-trigger" src="closed.png" alt="+"/> Inheritance diagram for hazelcast::client::ISemaphore:</div>
<div id="dynsection-0-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-0-content" class="dyncontent" style="display:none;">
 <div class="center">
  <img src="classhazelcast_1_1client_1_1_i_semaphore.png" usemap="#hazelcast::client::ISemaphore_map" alt=""/>
  <map id="hazelcast::client::ISemaphore_map" name="hazelcast::client::ISemaphore_map">
<area href="classhazelcast_1_1client_1_1_distributed_object.html" title="Base class for all distributed objects. " alt="hazelcast::client::DistributedObject" shape="rect" coords="0,0,204,24"/>
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:afb8252742d1cd824ade2e7afe6e2e244"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhazelcast_1_1client_1_1_i_semaphore.html#afb8252742d1cd824ade2e7afe6e2e244">init</a> (int permits)</td></tr>
<tr class="memdesc:afb8252742d1cd824ade2e7afe6e2e244"><td class="mdescLeft">&#160;</td><td class="mdescRight">Try to initialize this <a class="el" href="classhazelcast_1_1client_1_1_i_semaphore.html" title="ISemaphore is a backed-up distributed alternative to the java.util.concurrent.Semaphore. ">ISemaphore</a> instance with given permit count.  <a href="#afb8252742d1cd824ade2e7afe6e2e244">More...</a><br/></td></tr>
<tr class="separator:afb8252742d1cd824ade2e7afe6e2e244"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9160c1dfe84e2bfbdbe4e6218eaf3425"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhazelcast_1_1client_1_1_i_semaphore.html#a9160c1dfe84e2bfbdbe4e6218eaf3425">acquire</a> ()</td></tr>
<tr class="separator:a9160c1dfe84e2bfbdbe4e6218eaf3425"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fa0a8b2fa556f5e029d391f1b1d5b6c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhazelcast_1_1client_1_1_i_semaphore.html#a9fa0a8b2fa556f5e029d391f1b1d5b6c">acquire</a> (int permits)</td></tr>
<tr class="separator:a9fa0a8b2fa556f5e029d391f1b1d5b6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57de2c4b1a36f5cc093ab7ac2b8559dd"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhazelcast_1_1client_1_1_i_semaphore.html#a57de2c4b1a36f5cc093ab7ac2b8559dd">availablePermits</a> ()</td></tr>
<tr class="memdesc:a57de2c4b1a36f5cc093ab7ac2b8559dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the current number of permits currently available in this semaphore.  <a href="#a57de2c4b1a36f5cc093ab7ac2b8559dd">More...</a><br/></td></tr>
<tr class="separator:a57de2c4b1a36f5cc093ab7ac2b8559dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d1f14f5b8bc79ae521c83a869af78b3"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhazelcast_1_1client_1_1_i_semaphore.html#a9d1f14f5b8bc79ae521c83a869af78b3">drainPermits</a> ()</td></tr>
<tr class="memdesc:a9d1f14f5b8bc79ae521c83a869af78b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Acquires and returns all permits that are immediately available.  <a href="#a9d1f14f5b8bc79ae521c83a869af78b3">More...</a><br/></td></tr>
<tr class="separator:a9d1f14f5b8bc79ae521c83a869af78b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3f1c140bd4d2be7e2c92924aebbd40a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhazelcast_1_1client_1_1_i_semaphore.html#ab3f1c140bd4d2be7e2c92924aebbd40a">reducePermits</a> (int reduction)</td></tr>
<tr class="memdesc:ab3f1c140bd4d2be7e2c92924aebbd40a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shrinks the number of available permits by the indicated reduction.  <a href="#ab3f1c140bd4d2be7e2c92924aebbd40a">More...</a><br/></td></tr>
<tr class="separator:ab3f1c140bd4d2be7e2c92924aebbd40a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90d42809b37e2f71d462efcf40e29c75"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhazelcast_1_1client_1_1_i_semaphore.html#a90d42809b37e2f71d462efcf40e29c75">release</a> ()</td></tr>
<tr class="memdesc:a90d42809b37e2f71d462efcf40e29c75"><td class="mdescLeft">&#160;</td><td class="mdescRight">Releases a permit, increasing the number of available permits by one.  <a href="#a90d42809b37e2f71d462efcf40e29c75">More...</a><br/></td></tr>
<tr class="separator:a90d42809b37e2f71d462efcf40e29c75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26535625ccfd468d07f33ba95fc10853"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhazelcast_1_1client_1_1_i_semaphore.html#a26535625ccfd468d07f33ba95fc10853">release</a> (int permits)</td></tr>
<tr class="memdesc:a26535625ccfd468d07f33ba95fc10853"><td class="mdescLeft">&#160;</td><td class="mdescRight">Releases the given number of permits, increasing the number of available permits by that amount.  <a href="#a26535625ccfd468d07f33ba95fc10853">More...</a><br/></td></tr>
<tr class="separator:a26535625ccfd468d07f33ba95fc10853"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40f27c736f6ff1e71198fd3876e6ee14"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhazelcast_1_1client_1_1_i_semaphore.html#a40f27c736f6ff1e71198fd3876e6ee14">tryAcquire</a> ()</td></tr>
<tr class="memdesc:a40f27c736f6ff1e71198fd3876e6ee14"><td class="mdescLeft">&#160;</td><td class="mdescRight">Acquires a permit, if one is available and returns immediately, with the value true, reducing the number of available permits by one.  <a href="#a40f27c736f6ff1e71198fd3876e6ee14">More...</a><br/></td></tr>
<tr class="separator:a40f27c736f6ff1e71198fd3876e6ee14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43c4b0c7e500d3052b7532fc7c1c4ee9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhazelcast_1_1client_1_1_i_semaphore.html#a43c4b0c7e500d3052b7532fc7c1c4ee9">tryAcquire</a> (int permits)</td></tr>
<tr class="memdesc:a43c4b0c7e500d3052b7532fc7c1c4ee9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Acquires the given number of permits, if they are available, and returns immediately, with the value true, reducing the number of available permits by the given amount.  <a href="#a43c4b0c7e500d3052b7532fc7c1c4ee9">More...</a><br/></td></tr>
<tr class="separator:a43c4b0c7e500d3052b7532fc7c1c4ee9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc807381455c395f2dc731b797d0b2fb"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhazelcast_1_1client_1_1_i_semaphore.html#acc807381455c395f2dc731b797d0b2fb">tryAcquire</a> (long timeoutInMillis)</td></tr>
<tr class="memdesc:acc807381455c395f2dc731b797d0b2fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Acquires a permit from this semaphore, if one becomes available within the given waiting time and the current thread has not been interrupted.  <a href="#acc807381455c395f2dc731b797d0b2fb">More...</a><br/></td></tr>
<tr class="separator:acc807381455c395f2dc731b797d0b2fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f292e574cf353b3a45cd10123701e6b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhazelcast_1_1client_1_1_i_semaphore.html#a7f292e574cf353b3a45cd10123701e6b">tryAcquire</a> (int permits, long timeoutInMillis)</td></tr>
<tr class="memdesc:a7f292e574cf353b3a45cd10123701e6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Acquires the given number of permits, if they are available and returns immediately, with the value true, reducing the number of available permits by the given amount.  <a href="#a7f292e574cf353b3a45cd10123701e6b">More...</a><br/></td></tr>
<tr class="separator:a7f292e574cf353b3a45cd10123701e6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classhazelcast_1_1client_1_1_distributed_object"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classhazelcast_1_1client_1_1_distributed_object')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classhazelcast_1_1client_1_1_distributed_object.html">hazelcast::client::DistributedObject</a></td></tr>
<tr class="memitem:a1990ab399703e9e977f82e148a66e579 inherit pub_methods_classhazelcast_1_1client_1_1_distributed_object"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1990ab399703e9e977f82e148a66e579"></a>
const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhazelcast_1_1client_1_1_distributed_object.html#a1990ab399703e9e977f82e148a66e579">getServiceName</a> () const </td></tr>
<tr class="memdesc:a1990ab399703e9e977f82e148a66e579 inherit pub_methods_classhazelcast_1_1client_1_1_distributed_object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the service name for this object. <br/></td></tr>
<tr class="separator:a1990ab399703e9e977f82e148a66e579 inherit pub_methods_classhazelcast_1_1client_1_1_distributed_object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b690bc99d8eb5909b07f41e1d884dd7 inherit pub_methods_classhazelcast_1_1client_1_1_distributed_object"><td class="memItemLeft" align="right" valign="top">const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhazelcast_1_1client_1_1_distributed_object.html#a5b690bc99d8eb5909b07f41e1d884dd7">getName</a> () const </td></tr>
<tr class="memdesc:a5b690bc99d8eb5909b07f41e1d884dd7 inherit pub_methods_classhazelcast_1_1client_1_1_distributed_object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the unique name for this <a class="el" href="classhazelcast_1_1client_1_1_distributed_object.html" title="Base class for all distributed objects. ">DistributedObject</a>.  <a href="#a5b690bc99d8eb5909b07f41e1d884dd7">More...</a><br/></td></tr>
<tr class="separator:a5b690bc99d8eb5909b07f41e1d884dd7 inherit pub_methods_classhazelcast_1_1client_1_1_distributed_object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae306777232ed783347fac3d7c0cbea29 inherit pub_methods_classhazelcast_1_1client_1_1_distributed_object"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhazelcast_1_1client_1_1_distributed_object.html#ae306777232ed783347fac3d7c0cbea29">destroy</a> ()</td></tr>
<tr class="memdesc:ae306777232ed783347fac3d7c0cbea29 inherit pub_methods_classhazelcast_1_1client_1_1_distributed_object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys this object cluster-wide.  <a href="#ae306777232ed783347fac3d7c0cbea29">More...</a><br/></td></tr>
<tr class="separator:ae306777232ed783347fac3d7c0cbea29 inherit pub_methods_classhazelcast_1_1client_1_1_distributed_object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b4b8d43d7cebf43547758c9ae99339c inherit pub_methods_classhazelcast_1_1client_1_1_distributed_object"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3b4b8d43d7cebf43547758c9ae99339c"></a>
virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhazelcast_1_1client_1_1_distributed_object.html#a3b4b8d43d7cebf43547758c9ae99339c">~DistributedObject</a> ()</td></tr>
<tr class="memdesc:a3b4b8d43d7cebf43547758c9ae99339c inherit pub_methods_classhazelcast_1_1client_1_1_distributed_object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor. <br/></td></tr>
<tr class="separator:a3b4b8d43d7cebf43547758c9ae99339c inherit pub_methods_classhazelcast_1_1client_1_1_distributed_object"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a3f921619afb86782bcf850c139aea9ed"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3f921619afb86782bcf850c139aea9ed"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>HazelcastClient</b></td></tr>
<tr class="separator:a3f921619afb86782bcf850c139aea9ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pro_methods_classhazelcast_1_1client_1_1_distributed_object"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_classhazelcast_1_1client_1_1_distributed_object')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="classhazelcast_1_1client_1_1_distributed_object.html">hazelcast::client::DistributedObject</a></td></tr>
<tr class="memitem:a49e1596648b5787075dd6bca74588b01 inherit pro_methods_classhazelcast_1_1client_1_1_distributed_object"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a49e1596648b5787075dd6bca74588b01"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhazelcast_1_1client_1_1_distributed_object.html#a49e1596648b5787075dd6bca74588b01">DistributedObject</a> (const std::string &amp;serviceName, const std::string &amp;objectName, spi::ClientContext *context)</td></tr>
<tr class="memdesc:a49e1596648b5787075dd6bca74588b01 inherit pro_methods_classhazelcast_1_1client_1_1_distributed_object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor. <br/></td></tr>
<tr class="separator:a49e1596648b5787075dd6bca74588b01 inherit pro_methods_classhazelcast_1_1client_1_1_distributed_object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0be7a69383e36e0cec6d9e1a497d131 inherit pro_methods_classhazelcast_1_1client_1_1_distributed_object"><td class="memItemLeft" align="right" valign="top">spi::ClientContext &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhazelcast_1_1client_1_1_distributed_object.html#ad0be7a69383e36e0cec6d9e1a497d131">getContext</a> ()</td></tr>
<tr class="separator:ad0be7a69383e36e0cec6d9e1a497d131 inherit pro_methods_classhazelcast_1_1client_1_1_distributed_object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1161b36a20bdaa613c9d61b05e81c817 inherit pro_methods_classhazelcast_1_1client_1_1_distributed_object"><td class="memTemplParams" colspan="2">template&lt;typename Response &gt; </td></tr>
<tr class="memitem:a1161b36a20bdaa613c9d61b05e81c817 inherit pro_methods_classhazelcast_1_1client_1_1_distributed_object"><td class="memTemplItemLeft" align="right" valign="top">boost::shared_ptr&lt; Response &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classhazelcast_1_1client_1_1_distributed_object.html#a1161b36a20bdaa613c9d61b05e81c817">invoke</a> (const impl::PortableRequest *request, int partitionId)</td></tr>
<tr class="memdesc:a1161b36a20bdaa613c9d61b05e81c817 inherit pro_methods_classhazelcast_1_1client_1_1_distributed_object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal API.  <a href="#a1161b36a20bdaa613c9d61b05e81c817">More...</a><br/></td></tr>
<tr class="separator:a1161b36a20bdaa613c9d61b05e81c817 inherit pro_methods_classhazelcast_1_1client_1_1_distributed_object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b8f8b80773ee29b0bb1771ececfed98 inherit pro_methods_classhazelcast_1_1client_1_1_distributed_object"><td class="memTemplParams" colspan="2">template&lt;typename Response &gt; </td></tr>
<tr class="memitem:a9b8f8b80773ee29b0bb1771ececfed98 inherit pro_methods_classhazelcast_1_1client_1_1_distributed_object"><td class="memTemplItemLeft" align="right" valign="top">boost::shared_ptr&lt; Response &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classhazelcast_1_1client_1_1_distributed_object.html#a9b8f8b80773ee29b0bb1771ececfed98">invoke</a> (const impl::PortableRequest *request)</td></tr>
<tr class="memdesc:a9b8f8b80773ee29b0bb1771ececfed98 inherit pro_methods_classhazelcast_1_1client_1_1_distributed_object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal API.  <a href="#a9b8f8b80773ee29b0bb1771ececfed98">More...</a><br/></td></tr>
<tr class="separator:a9b8f8b80773ee29b0bb1771ececfed98 inherit pro_methods_classhazelcast_1_1client_1_1_distributed_object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3a7241818c4291dd93250584f8d2952 inherit pro_methods_classhazelcast_1_1client_1_1_distributed_object"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhazelcast_1_1client_1_1_distributed_object.html#ac3a7241818c4291dd93250584f8d2952">listen</a> (const impl::PortableRequest *registrationRequest, int partitionId, impl::BaseEventHandler *handler)</td></tr>
<tr class="memdesc:ac3a7241818c4291dd93250584f8d2952 inherit pro_methods_classhazelcast_1_1client_1_1_distributed_object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal API.  <a href="#ac3a7241818c4291dd93250584f8d2952">More...</a><br/></td></tr>
<tr class="separator:ac3a7241818c4291dd93250584f8d2952 inherit pro_methods_classhazelcast_1_1client_1_1_distributed_object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b5b938cbc44bb712555474dd350c21e inherit pro_methods_classhazelcast_1_1client_1_1_distributed_object"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhazelcast_1_1client_1_1_distributed_object.html#a2b5b938cbc44bb712555474dd350c21e">listen</a> (const impl::PortableRequest *registrationRequest, impl::BaseEventHandler *handler)</td></tr>
<tr class="memdesc:a2b5b938cbc44bb712555474dd350c21e inherit pro_methods_classhazelcast_1_1client_1_1_distributed_object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal API.  <a href="#a2b5b938cbc44bb712555474dd350c21e">More...</a><br/></td></tr>
<tr class="separator:a2b5b938cbc44bb712555474dd350c21e inherit pro_methods_classhazelcast_1_1client_1_1_distributed_object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7842fa1472d63193822acfb9ab4a1b34 inherit pro_methods_classhazelcast_1_1client_1_1_distributed_object"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhazelcast_1_1client_1_1_distributed_object.html#a7842fa1472d63193822acfb9ab4a1b34">stopListening</a> (impl::BaseRemoveListenerRequest *request, const std::string &amp;registrationId)</td></tr>
<tr class="memdesc:a7842fa1472d63193822acfb9ab4a1b34 inherit pro_methods_classhazelcast_1_1client_1_1_distributed_object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal API.  <a href="#a7842fa1472d63193822acfb9ab4a1b34">More...</a><br/></td></tr>
<tr class="separator:a7842fa1472d63193822acfb9ab4a1b34 inherit pro_methods_classhazelcast_1_1client_1_1_distributed_object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8efd57d3aeb21387878dd90436d7f499 inherit pro_methods_classhazelcast_1_1client_1_1_distributed_object"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhazelcast_1_1client_1_1_distributed_object.html#a8efd57d3aeb21387878dd90436d7f499">getPartitionId</a> (const serialization::pimpl::Data &amp;key)</td></tr>
<tr class="memdesc:a8efd57d3aeb21387878dd90436d7f499 inherit pro_methods_classhazelcast_1_1client_1_1_distributed_object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal API.  <a href="#a8efd57d3aeb21387878dd90436d7f499">More...</a><br/></td></tr>
<tr class="separator:a8efd57d3aeb21387878dd90436d7f499 inherit pro_methods_classhazelcast_1_1client_1_1_distributed_object"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p><a class="el" href="classhazelcast_1_1client_1_1_i_semaphore.html" title="ISemaphore is a backed-up distributed alternative to the java.util.concurrent.Semaphore. ">ISemaphore</a> is a backed-up distributed alternative to the java.util.concurrent.Semaphore. </p>
<p><a class="el" href="classhazelcast_1_1client_1_1_i_semaphore.html" title="ISemaphore is a backed-up distributed alternative to the java.util.concurrent.Semaphore. ">ISemaphore</a> is a cluster-wide counting semaphore. Conceptually, it maintains a set of permits. Each <a class="el" href="classhazelcast_1_1client_1_1_i_semaphore.html#a9160c1dfe84e2bfbdbe4e6218eaf3425">acquire()</a> blocks if necessary until a permit is available, and then takes it. Each <a class="el" href="classhazelcast_1_1client_1_1_i_semaphore.html#a90d42809b37e2f71d462efcf40e29c75" title="Releases a permit, increasing the number of available permits by one. ">release()</a> adds a permit, potentially releasing a blocking acquirer. However, no actual permit objects are used; the semaphore just keeps a count of the number available and acts accordingly. </p>
<p>The Hazelcast distributed semaphore implementation guarantees that threads invoking any of the acquire methods are selected to obtain permits in the order in which their invocation of those methods was processed(first-in-first-out; FIFO). Note that FIFO ordering necessarily applies to specific internal points of execution within the cluster. So, it is possible for one member to invoke acquire before another, but reach the ordering point after the other, and similarly upon return from the method. </p>
<p>This class also provides convenience methods to acquire and <a class="el" href="classhazelcast_1_1client_1_1_i_semaphore.html#a26535625ccfd468d07f33ba95fc10853" title="Releases the given number of permits, increasing the number of available permits by that amount...">release(int)</a> release multiple permits at a time. Beware of the increased risk of indefinite postponement when using the multiple acquire. If a single permit is released to a semaphore that is currently blocking, a thread waiting for one permit will acquire it before a thread waiting for multiple permits regardless of the call order. </p>
<ul>
<li>
Correct usage of a semaphore is established by programming convention in the application. </li>
</ul>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a9160c1dfe84e2bfbdbe4e6218eaf3425"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void hazelcast::client::ISemaphore::acquire </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Acquires a permit, if one is available and returns immediately, reducing the number of available permits by one.</p>
<p>If no permit is available then the current thread becomes disabled for thread scheduling purposes and lies dormant until one of three things happens: </p>
<ul>
<li>
Some other thread invokes one of the <a class="el" href="classhazelcast_1_1client_1_1_i_semaphore.html#a90d42809b37e2f71d462efcf40e29c75" title="Releases a permit, increasing the number of available permits by one. ">release</a> methods for this semaphore and the current thread is next to be assigned a permit; </li>
<li>
This <a class="el" href="classhazelcast_1_1client_1_1_i_semaphore.html" title="ISemaphore is a backed-up distributed alternative to the java.util.concurrent.Semaphore. ">ISemaphore</a> instance is destroyed; or </li>
<li>
Some other thread interrupts the current thread. </li>
</ul>
<p>If the current thread: </p>
<ul>
<li>
has its interrupted status set on entry to this method; or </li>
<li>
is interrupted while waiting for a permit, </li>
</ul>
<p>then InterruptedException is thrown and the current thread's interrupted status is cleared.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">InterruptedException</td><td>if the current thread is interrupted </td></tr>
    <tr><td class="paramname">IllegalStateException</td><td>if hazelcast instance is shutdown while waiting </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a9fa0a8b2fa556f5e029d391f1b1d5b6c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void hazelcast::client::ISemaphore::acquire </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>permits</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Acquires the given number of permits, if they are available, and returns immediately, reducing the number of available permits by the given amount.</p>
<p>If insufficient permits are available then the current thread becomes disabled for thread scheduling purposes and lies dormant until one of three things happens: </p>
<ul>
<li>
Some other thread invokes one of the <a class="el" href="classhazelcast_1_1client_1_1_i_semaphore.html#a90d42809b37e2f71d462efcf40e29c75" title="Releases a permit, increasing the number of available permits by one. ">release()</a> release methods for this semaphore, the current thread is next to be assigned permits and the number of available permits satisfies this request; </li>
<li>
This <a class="el" href="classhazelcast_1_1client_1_1_i_semaphore.html" title="ISemaphore is a backed-up distributed alternative to the java.util.concurrent.Semaphore. ">ISemaphore</a> instance is destroyed; or </li>
<li>
Some other thread interrupts the current thread. </li>
</ul>
<p>If the current thread: </p>
<ul>
<li>
has its interrupted status set on entry to this method; or </li>
<li>
is interrupted while waiting for a permit, </li>
</ul>
<p>then InterruptedException is thrown and the current thread's interrupted status is cleared.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">permits</td><td>the number of permits to acquire </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">InterruptedException</td><td>if the current thread is interrupted </td></tr>
    <tr><td class="paramname">IllegalStateException</td><td>if hazelcast instance is shutdown while waiting </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a57de2c4b1a36f5cc093ab7ac2b8559dd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int hazelcast::client::ISemaphore::availablePermits </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the current number of permits currently available in this semaphore. </p>
<ul>
<li>
This method is typically used for debugging and testing purposes. </li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>the number of permits available in this semaphore </dd></dl>

</div>
</div>
<a class="anchor" id="a9d1f14f5b8bc79ae521c83a869af78b3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int hazelcast::client::ISemaphore::drainPermits </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Acquires and returns all permits that are immediately available. </p>
<dl class="section return"><dt>Returns</dt><dd>the number of permits drained </dd></dl>

</div>
</div>
<a class="anchor" id="afb8252742d1cd824ade2e7afe6e2e244"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool hazelcast::client::ISemaphore::init </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>permits</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Try to initialize this <a class="el" href="classhazelcast_1_1client_1_1_i_semaphore.html" title="ISemaphore is a backed-up distributed alternative to the java.util.concurrent.Semaphore. ">ISemaphore</a> instance with given permit count. </p>
<dl class="section return"><dt>Returns</dt><dd>true if initialization success </dd></dl>

</div>
</div>
<a class="anchor" id="ab3f1c140bd4d2be7e2c92924aebbd40a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void hazelcast::client::ISemaphore::reducePermits </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>reduction</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Shrinks the number of available permits by the indicated reduction. </p>
<p>This method differs from acquire in that it does not block waiting for permits to become available.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">reduction</td><td>the number of permits to remove </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">IllegalArgumentException</td><td>if reduction is negative </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a90d42809b37e2f71d462efcf40e29c75"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void hazelcast::client::ISemaphore::release </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Releases a permit, increasing the number of available permits by one. </p>
<p>If any threads in the cluster are trying to acquire a permit, then one is selected and given the permit that was just released.</p>
<p>There is no requirement that a thread that releases a permit must have acquired that permit by calling one of the <a class="el" href="classhazelcast_1_1client_1_1_i_semaphore.html#a9160c1dfe84e2bfbdbe4e6218eaf3425">acquire()</a> acquire methods. Correct usage of a semaphore is established by programming convention in the application. </p>

</div>
</div>
<a class="anchor" id="a26535625ccfd468d07f33ba95fc10853"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void hazelcast::client::ISemaphore::release </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>permits</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Releases the given number of permits, increasing the number of available permits by that amount. </p>
<p>There is no requirement that a thread that releases a permit must have acquired that permit by calling one of the <a class="el" href="classhazelcast_1_1client_1_1_i_semaphore.html#a9160c1dfe84e2bfbdbe4e6218eaf3425">acquire()</a> acquire methods. Correct usage of a semaphore is established by programming convention in the application.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">permits</td><td>the number of permits to release </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a40f27c736f6ff1e71198fd3876e6ee14"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool hazelcast::client::ISemaphore::tryAcquire </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Acquires a permit, if one is available and returns immediately, with the value true, reducing the number of available permits by one. </p>
<p>If no permit is available then this method will return immediately with the value false.</p>
<dl class="section return"><dt>Returns</dt><dd>true if a permit was acquired and false otherwise </dd></dl>

</div>
</div>
<a class="anchor" id="a43c4b0c7e500d3052b7532fc7c1c4ee9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool hazelcast::client::ISemaphore::tryAcquire </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>permits</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Acquires the given number of permits, if they are available, and returns immediately, with the value true, reducing the number of available permits by the given amount. </p>
<p>If insufficient permits are available then this method will return immediately with the value false and the number of available permits is unchanged.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">permits</td><td>the number of permits to acquire </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the permits were acquired and false otherwise </dd></dl>

</div>
</div>
<a class="anchor" id="acc807381455c395f2dc731b797d0b2fb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool hazelcast::client::ISemaphore::tryAcquire </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>timeoutInMillis</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Acquires a permit from this semaphore, if one becomes available within the given waiting time and the current thread has not been interrupted. </p>
<p>Acquires a permit, if one is available and returns immediately, with the value true, reducing the number of available permits by one.</p>
<p>If no permit is available then the current thread becomes disabled for thread scheduling purposes and lies dormant until one of three things happens: </p>
<ul>
<li>
Some other thread invokes the <a class="el" href="classhazelcast_1_1client_1_1_i_semaphore.html#a90d42809b37e2f71d462efcf40e29c75" title="Releases a permit, increasing the number of available permits by one. ">release</a> method for this semaphore and the current thread is next to be assigned a permit; or </li>
<li>
Some other thread interrupts the current thread; or </li>
<li>
The specified waiting time elapses. </li>
</ul>
<p>If a permit is acquired then the value true is returned.</p>
<p>If the specified waiting time elapses then the value false is returned. If the time is less than or equal to zero, the method will not wait at all.</p>
<p>If the current thread: </p>
<ul>
<li>
has its interrupted status set on entry to this method; or </li>
<li>
is interrupted while waiting for a permit, </li>
</ul>
<p>then InterruptedException is thrown and the current thread's interrupted status is cleared.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">timeout</td><td>the maximum time to wait for a permit </td></tr>
    <tr><td class="paramname">unit</td><td>the time unit of the timeout argument </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if a permit was acquired and false if the waiting time elapsed before a permit was acquired </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">InterruptedException</td><td>if the current thread is interrupted </td></tr>
    <tr><td class="paramname">IllegalStateException</td><td>if hazelcast instance is shutdown while waiting </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a7f292e574cf353b3a45cd10123701e6b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool hazelcast::client::ISemaphore::tryAcquire </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>permits</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>timeoutInMillis</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Acquires the given number of permits, if they are available and returns immediately, with the value true, reducing the number of available permits by the given amount. </p>
<p>If insufficient permits are available then the current thread becomes disabled for thread scheduling purposes and lies dormant until one of three things happens: </p>
<ul>
<li>
Some other thread invokes one of the <a class="el" href="classhazelcast_1_1client_1_1_i_semaphore.html#a90d42809b37e2f71d462efcf40e29c75" title="Releases a permit, increasing the number of available permits by one. ">release()</a> release methods for this semaphore, the current thread is next to be assigned permits and the number of available permits satisfies this request; or </li>
<li>
Some other thread interrupts the current thread; or </li>
<li>
The specified waiting time elapses. </li>
</ul>
<p>If the permits are acquired then the value true is returned.</p>
<p>If the specified waiting time elapses then the value false is returned. If the time is less than or equal to zero, the method will not wait at all.</p>
<p>If the current thread: </p>
<ul>
<li>
has its interrupted status set on entry to this method; or </li>
<li>
is interrupted while waiting for a permit, </li>
</ul>
<p>then InterruptedException is thrown and the current thread's interrupted status is cleared.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">permits</td><td>the number of permits to acquire </td></tr>
    <tr><td class="paramname">timeout</td><td>the maximum time to wait for the permits </td></tr>
    <tr><td class="paramname">unit</td><td>the time unit of the timeout argument </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if all permits were acquired and false if the waiting time elapsed before all permits could be acquired </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">InterruptedException</td><td>if the current thread is interrupted </td></tr>
    <tr><td class="paramname">IllegalStateException</td><td>if hazelcast instance is shutdown while waiting </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>hazelcast/include/hazelcast/client/<a class="el" href="_i_semaphore_8h_source.html">ISemaphore.h</a></li>
<li>hazelcast/src/hazelcast/client/ISemaphore.cpp</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Thu May 15 2014 16:20:22 for Hazelcast C++ Client by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.5
</small></address>
</body>
</html>
